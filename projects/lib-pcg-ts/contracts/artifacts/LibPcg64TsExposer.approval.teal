#pragma version 10

// This TEAL was generated by TEALScript v0.88.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// __twosComplement(value: uint64): uint64
__twosComplement:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/lib-pcg32-ts.algo.ts:6
	// addwResult = addw(~value, 1)
	frame_dig -1 // value: uint64
	~
	int 1
	addw
	frame_bury 2 // addwResult low: uint64
	frame_bury 3 // addwResult high: uint64

	// contracts/lib-pcg32-ts.algo.ts:7
	// return addwResult.low;
	frame_dig 2 // addwResult low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// __maskToUint32(value: uint64): uint64
__maskToUint32:
	proto 1 1

	// contracts/lib-pcg32-ts.algo.ts:11
	// return value & 4294967295;
	frame_dig -1 // value: uint64
	int 4294967295
	&
	retsub

// __pcg32Step(state: uint64, incr: uint64): uint64
__pcg32Step:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// contracts/lib-pcg32-ts.algo.ts:15
	// mulwResult = mulw(state, 6364136223846793005)
	frame_dig -1 // state: uint64
	int 6364136223846793005
	mulw
	frame_bury 2 // mulwResult low: uint64
	frame_bury 3 // mulwResult high: uint64

	// contracts/lib-pcg32-ts.algo.ts:16
	// addwResult = addw(mulwResult.low, incr)
	frame_dig 2 // mulwResult low: uint64
	frame_dig -2 // incr: uint64
	addw
	frame_bury 6 // addwResult low: uint64
	frame_bury 7 // addwResult high: uint64

	// contracts/lib-pcg32-ts.algo.ts:18
	// return addwResult.low;
	frame_dig 6 // addwResult low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// __pcg32Rotation(value: uint64, rot: uint64): uint64
__pcg32Rotation:
	proto 2 1

	// contracts/lib-pcg32-ts.algo.ts:22
	// return (value >> rot) | this.__maskToUint32(value << (this.__twosComplement(rot) & 31));
	frame_dig -1 // value: uint64
	frame_dig -2 // rot: uint64
	shr
	frame_dig -1 // value: uint64
	frame_dig -2 // rot: uint64
	callsub __twosComplement
	int 31
	&
	shl
	callsub __maskToUint32
	|
	retsub

// __pcg32Output(state: uint64): uint64
__pcg32Output:
	proto 1 1

	// contracts/lib-pcg32-ts.algo.ts:26
	// return this.__pcg32Rotation(this.__maskToUint32(((state >> 18) ^ state) >> 27), state >> 59);
	frame_dig -1 // state: uint64
	int 59
	shr
	frame_dig -1 // state: uint64
	int 18
	shr
	frame_dig -1 // state: uint64
	^
	int 27
	shr
	callsub __maskToUint32
	callsub __pcg32Rotation
	retsub

// __pcg32Random(state: uint64): [uint64, uint64]
__pcg32Random:
	proto 1 1

	// contracts/lib-pcg32-ts.algo.ts:30
	// return [this.__pcg32Step(state, 1442695040888963407), this.__pcg32Output(state)];
	int 1442695040888963407
	frame_dig -1 // state: uint64
	callsub __pcg32Step
	itob
	frame_dig -1 // state: uint64
	callsub __pcg32Output
	itob
	concat
	retsub

// __pcg32Init(initialState: uint64, incr: uint64): uint64
__pcg32Init:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/lib-pcg32-ts.algo.ts:34
	// state = this.__pcg32Step(0, incr)
	frame_dig -2 // incr: uint64
	int 0
	callsub __pcg32Step
	frame_bury 0 // state: uint64

	// contracts/lib-pcg32-ts.algo.ts:35
	// addwResult = addw(state, initialState)
	frame_dig 0 // state: uint64
	frame_dig -1 // initialState: uint64
	addw
	frame_bury 3 // addwResult low: uint64
	frame_bury 4 // addwResult high: uint64

	// contracts/lib-pcg32-ts.algo.ts:37
	// return this.__pcg32Step(addwResult.low, incr);
	frame_dig -2 // incr: uint64
	frame_dig 3 // addwResult low: uint64
	callsub __pcg32Step

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// pcg32Init(initialState: uint64): uint64
pcg32Init:
	proto 1 1

	// contracts/lib-pcg32-ts.algo.ts:41
	// return this.__pcg32Init(initialState, 1442695040888963407);
	int 1442695040888963407
	frame_dig -1 // initialState: uint64
	callsub __pcg32Init
	retsub

// pcg32Random(state: uint64, bitSize: uint64, lowerBound: uint64, upperBound: uint64, length: uint64): [uint64, bytes]
pcg32Random:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 8

	// contracts/lib-pcg32-ts.algo.ts:51
	// result: bytes = ''
	byte 0x // ""
	frame_bury 0 // result: bytes

	// contracts/lib-pcg32-ts.algo.ts:55
	// assert(length < 65536)
	frame_dig -5 // length: uint64
	int 65536
	<
	assert

	// contracts/lib-pcg32-ts.algo.ts:57
	// assert(bitSize === 8 || bitSize === 16 || bitSize === 32)
	frame_dig -2 // bitSize: uint64
	int 8
	==
	dup
	bnz *skip_or0
	frame_dig -2 // bitSize: uint64
	int 16
	==
	||

*skip_or0:
	dup
	bnz *skip_or1
	frame_dig -2 // bitSize: uint64
	int 32
	==
	||

*skip_or1:
	assert

	// contracts/lib-pcg32-ts.algo.ts:58
	// byteSize = bitSize >> 3
	frame_dig -2 // bitSize: uint64
	int 3
	shr
	frame_bury 3 // byteSize: uint64

	// contracts/lib-pcg32-ts.algo.ts:59
	// truncateStartCached = 8 - byteSize
	int 8
	frame_dig 3 // byteSize: uint64
	-
	frame_bury 4 // truncateStartCached: uint64

	// *if0_condition
	// contracts/lib-pcg32-ts.algo.ts:61
	// lowerBound === 0 && upperBound === 0
	frame_dig -3 // lowerBound: uint64
	int 0
	==
	dup
	bz *skip_and0
	frame_dig -4 // upperBound: uint64
	int 0
	==
	&&

*skip_and0:
	bz *if0_else

	// *if0_consequent
	// contracts/lib-pcg32-ts.algo.ts:62
	// for (let i = 0; i < length; i = i + 1)
	int 0
	frame_bury 5 // i: uint64

*for_0:
	// contracts/lib-pcg32-ts.algo.ts:62
	// i < length
	frame_dig 5 // i: uint64
	frame_dig -5 // length: uint64
	<
	bz *for_0_end

	// contracts/lib-pcg32-ts.algo.ts:63
	// prn = this.__pcg32Random(state)
	frame_dig -1 // state: uint64
	callsub __pcg32Random
	frame_bury 6 // prn: (uint64,uint64)

	// contracts/lib-pcg32-ts.algo.ts:64
	// state = prn[0]
	frame_dig 6 // prn: (uint64,uint64)
	extract 0 8
	btoi
	frame_bury -1 // state: uint64

	// contracts/lib-pcg32-ts.algo.ts:65
	// result += extract3(itob(prn[1]), truncateStartCached, byteSize)
	frame_dig 0 // result: bytes
	frame_dig 6 // prn: (uint64,uint64)
	extract 8 8
	btoi
	itob
	frame_dig 4 // truncateStartCached: uint64
	frame_dig 3 // byteSize: uint64
	extract3
	concat
	frame_bury 0 // result: bytes

*for_0_continue:
	// contracts/lib-pcg32-ts.algo.ts:62
	// i = i + 1
	frame_dig 5 // i: uint64
	int 1
	+
	frame_bury 5 // i: uint64
	b *for_0

*for_0_end:
	b *if0_end

*if0_else:
	// *if1_condition
	// contracts/lib-pcg32-ts.algo.ts:68
	// upperBound !== 0
	frame_dig -4 // upperBound: uint64
	int 0
	!=
	bz *if1_else

	// *if1_consequent
	// contracts/lib-pcg32-ts.algo.ts:69
	// assert(upperBound > 1)
	frame_dig -4 // upperBound: uint64
	int 1
	>
	assert

	// contracts/lib-pcg32-ts.algo.ts:70
	// assert(upperBound < 1 << bitSize)
	frame_dig -4 // upperBound: uint64
	int 1
	frame_dig -2 // bitSize: uint64
	shl
	<
	assert

	// contracts/lib-pcg32-ts.algo.ts:72
	// assert(lowerBound < upperBound - 1)
	frame_dig -3 // lowerBound: uint64
	frame_dig -4 // upperBound: uint64
	int 1
	-
	<
	assert

	// contracts/lib-pcg32-ts.algo.ts:74
	// absoluteBound = upperBound - lowerBound
	frame_dig -4 // upperBound: uint64
	frame_dig -3 // lowerBound: uint64
	-
	frame_bury 1 // absoluteBound: uint64
	b *if1_end

*if1_else:
	// contracts/lib-pcg32-ts.algo.ts:76
	// assert(lowerBound < (1 << bitSize) - 1)
	frame_dig -3 // lowerBound: uint64
	int 1
	frame_dig -2 // bitSize: uint64
	shl
	int 1
	-
	<
	assert

	// contracts/lib-pcg32-ts.algo.ts:78
	// absoluteBound = (1 << bitSize) - lowerBound
	int 1
	frame_dig -2 // bitSize: uint64
	shl
	frame_dig -3 // lowerBound: uint64
	-
	frame_bury 1 // absoluteBound: uint64

*if1_end:
	// contracts/lib-pcg32-ts.algo.ts:81
	// threshold = this.__maskToUint32(this.__twosComplement(absoluteBound)) % absoluteBound
	frame_dig 1 // absoluteBound: uint64
	callsub __twosComplement
	callsub __maskToUint32
	frame_dig 1 // absoluteBound: uint64
	%
	frame_bury 2 // threshold: uint64

	// contracts/lib-pcg32-ts.algo.ts:83
	// for (let i = 0; i < length; i = i + 1)
	int 0
	frame_bury 7 // i: uint64

*for_1:
	// contracts/lib-pcg32-ts.algo.ts:83
	// i < length
	frame_dig 7 // i: uint64
	frame_dig -5 // length: uint64
	<
	bz *for_1_end

*while_0:

*while_0_continue:
	// contracts/lib-pcg32-ts.algo.ts:86
	// true
	int 1
	bz *while_0_end

	// contracts/lib-pcg32-ts.algo.ts:87
	// prn = this.__pcg32Random(state)
	frame_dig -1 // state: uint64
	callsub __pcg32Random
	frame_bury 8 // prn: [uint64, uint64]

	// contracts/lib-pcg32-ts.algo.ts:88
	// state = prn[0]
	frame_dig 8 // prn: [uint64, uint64]
	extract 0 8
	btoi
	frame_bury -1 // state: uint64

	// *if2_condition
	// contracts/lib-pcg32-ts.algo.ts:89
	// prn[1] >= threshold
	frame_dig 8 // prn: [uint64, uint64]
	extract 8 8
	btoi
	frame_dig 2 // threshold: uint64
	>=
	bz *if2_end

	// *if2_consequent
	b *while_0_end

*if2_end:
	b *while_0

*while_0_end:
	// contracts/lib-pcg32-ts.algo.ts:94
	// result += extract3(itob((prn[1] % absoluteBound) + lowerBound), truncateStartCached, byteSize)
	frame_dig 0 // result: bytes
	frame_dig 8 // prn: [uint64, uint64]
	extract 8 8
	btoi
	frame_dig 1 // absoluteBound: uint64
	%
	frame_dig -3 // lowerBound: uint64
	+
	itob
	frame_dig 4 // truncateStartCached: uint64
	frame_dig 3 // byteSize: uint64
	extract3
	concat
	frame_bury 0 // result: bytes

*for_1_continue:
	// contracts/lib-pcg32-ts.algo.ts:83
	// i = i + 1
	frame_dig 7 // i: uint64
	int 1
	+
	frame_bury 7 // i: uint64
	b *for_1

*for_1_end:

*if0_end:
	// contracts/lib-pcg32-ts.algo.ts:98
	// return [state, result];
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x000a // initial head offset
	frame_dig -1 // state: uint64
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // result: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// __pcg64Random(state: [uint64, uint64]): [[uint64, uint64], uint64]
__pcg64Random:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/lib-pcg64-ts.algo.ts:6
	// prn1 = this.__pcg32Random(state[0])
	frame_dig -1 // state: [uint64, uint64]
	extract 0 8
	btoi
	callsub __pcg32Random
	frame_bury 0 // prn1: (uint64,uint64)

	// *if3_condition
	// contracts/lib-pcg64-ts.algo.ts:8
	// prn1[0] === 0
	frame_dig 0 // prn1: (uint64,uint64)
	extract 0 8
	btoi
	int 0
	==
	bz *if3_else

	// *if3_consequent
	// contracts/lib-pcg64-ts.algo.ts:9
	// prn2 = this.__pcg32Step(state[1], 1442695040888963409 << 1)
	int 1442695040888963409
	int 1
	shl
	frame_dig -1 // state: [uint64, uint64]
	extract 8 8
	btoi
	callsub __pcg32Step
	frame_bury 1 // prn2: uint64
	b *if3_end

*if3_else:
	// contracts/lib-pcg64-ts.algo.ts:11
	// prn2 = this.__pcg32Step(state[1], 1442695040888963409)
	int 1442695040888963409
	frame_dig -1 // state: [uint64, uint64]
	extract 8 8
	btoi
	callsub __pcg32Step
	frame_bury 1 // prn2: uint64

*if3_end:
	// contracts/lib-pcg64-ts.algo.ts:14
	// return [[prn1[0], prn2], (prn1[1] << 32) | this.__pcg32Output(state[1])];
	frame_dig 0 // prn1: (uint64,uint64)
	extract 0 8
	btoi
	itob
	frame_dig 1 // prn2: uint64
	itob
	concat
	frame_dig 0 // prn1: (uint64,uint64)
	extract 8 8
	btoi
	int 32
	shl
	frame_dig -1 // state: [uint64, uint64]
	extract 8 8
	btoi
	callsub __pcg32Output
	|
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// pcg64Init(state: [uint64, uint64]): [uint64, uint64]
pcg64Init:
	proto 1 1

	// contracts/lib-pcg64-ts.algo.ts:18
	// return [this.__pcg32Init(state[0], 1442695040888963407), this.__pcg32Init(state[1], 1442695040888963409)];
	int 1442695040888963407
	frame_dig -1 // state: [uint64, uint64]
	extract 0 8
	btoi
	callsub __pcg32Init
	itob
	int 1442695040888963409
	frame_dig -1 // state: [uint64, uint64]
	extract 8 8
	btoi
	callsub __pcg32Init
	itob
	concat
	retsub

// pcg64Random(state: [uint64, uint64], lowerBound: uint64, upperBound: uint64, length: uint64): [[uint64, uint64], uint64[]]
pcg64Random:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 8

	// contracts/lib-pcg64-ts.algo.ts:27
	// result: uint64[] = []
	byte 0x
	frame_bury 0 // result: uint64[]

	// contracts/lib-pcg64-ts.algo.ts:31
	// assert(length < 65536)
	frame_dig -4 // length: uint64
	int 65536
	<
	assert

	// contracts/lib-pcg64-ts.algo.ts:35
	// newState = state
	frame_dig -1 // state: [uint64, uint64]
	frame_bury 3 // newState: [uint64, uint64]

	// *if4_condition
	// contracts/lib-pcg64-ts.algo.ts:37
	// lowerBound === 0 && upperBound === 0
	frame_dig -2 // lowerBound: uint64
	int 0
	==
	dup
	bz *skip_and1
	frame_dig -3 // upperBound: uint64
	int 0
	==
	&&

*skip_and1:
	bz *if4_else

	// *if4_consequent
	// contracts/lib-pcg64-ts.algo.ts:38
	// for (let i = 0; i < length; i = i + 1)
	int 0
	frame_bury 5 // i: uint64

*for_2:
	// contracts/lib-pcg64-ts.algo.ts:38
	// i < length
	frame_dig 5 // i: uint64
	frame_dig -4 // length: uint64
	<
	bz *for_2_end

	// contracts/lib-pcg64-ts.algo.ts:39
	// temp = this.__pcg64Random(newState)
	frame_dig 3 // newState: [uint64, uint64]
	callsub __pcg64Random
	frame_bury 6 // temp: ((uint64,uint64),uint64)

	// contracts/lib-pcg64-ts.algo.ts:40
	// newState = temp[0]
	frame_dig 6 // temp: ((uint64,uint64),uint64)
	extract 0 16
	frame_bury 3 // newState: [uint64, uint64]

	// contracts/lib-pcg64-ts.algo.ts:41
	// n = temp[1]
	frame_dig 6 // temp: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	frame_bury 4 // n: uint64

	// contracts/lib-pcg64-ts.algo.ts:42
	// result.push(n)
	frame_dig 0 // result: uint64[]
	frame_dig 4 // n: uint64
	itob
	concat
	frame_bury 0 // result: uint64[]

*for_2_continue:
	// contracts/lib-pcg64-ts.algo.ts:38
	// i = i + 1
	frame_dig 5 // i: uint64
	int 1
	+
	frame_bury 5 // i: uint64
	b *for_2

*for_2_end:
	b *if4_end

*if4_else:
	// *if5_condition
	// contracts/lib-pcg64-ts.algo.ts:45
	// upperBound !== 0
	frame_dig -3 // upperBound: uint64
	int 0
	!=
	bz *if5_else

	// *if5_consequent
	// contracts/lib-pcg64-ts.algo.ts:46
	// assert(upperBound > 1)
	frame_dig -3 // upperBound: uint64
	int 1
	>
	assert

	// contracts/lib-pcg64-ts.algo.ts:47
	// assert(lowerBound < upperBound - 1)
	frame_dig -2 // lowerBound: uint64
	frame_dig -3 // upperBound: uint64
	int 1
	-
	<
	assert

	// contracts/lib-pcg64-ts.algo.ts:49
	// absoluteBound = upperBound - lowerBound
	frame_dig -3 // upperBound: uint64
	frame_dig -2 // lowerBound: uint64
	-
	frame_bury 1 // absoluteBound: uint64
	b *if5_end

*if5_else:
	// contracts/lib-pcg64-ts.algo.ts:51
	// assert(lowerBound < 18446744073709551615)
	frame_dig -2 // lowerBound: uint64
	int 18446744073709551615
	<
	assert

	// contracts/lib-pcg64-ts.algo.ts:53
	// absoluteBound = ((18446744073709551616 as uint128) - (lowerBound as uint128)) as uint64
	byte 0x00000000000000010000000000000000
	frame_dig -2 // lowerBound: uint64
	itob
	b-
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 1 // absoluteBound: uint64

*if5_end:
	// contracts/lib-pcg64-ts.algo.ts:56
	// threshold = this.__twosComplement(absoluteBound) % absoluteBound
	frame_dig 1 // absoluteBound: uint64
	callsub __twosComplement
	frame_dig 1 // absoluteBound: uint64
	%
	frame_bury 2 // threshold: uint64

	// contracts/lib-pcg64-ts.algo.ts:58
	// for (let i = 0; i < length; i = i + 1)
	int 0
	frame_bury 7 // i: uint64

*for_3:
	// contracts/lib-pcg64-ts.algo.ts:58
	// i < length
	frame_dig 7 // i: uint64
	frame_dig -4 // length: uint64
	<
	bz *for_3_end

*while_1:

*while_1_continue:
	// contracts/lib-pcg64-ts.algo.ts:60
	// true
	int 1
	bz *while_1_end

	// contracts/lib-pcg64-ts.algo.ts:61
	// temp = this.__pcg64Random(newState)
	frame_dig 3 // newState: [uint64, uint64]
	callsub __pcg64Random
	frame_bury 8 // temp: ((uint64,uint64),uint64)

	// contracts/lib-pcg64-ts.algo.ts:62
	// newState = temp[0]
	frame_dig 8 // temp: ((uint64,uint64),uint64)
	extract 0 16
	frame_bury 3 // newState: [uint64, uint64]

	// contracts/lib-pcg64-ts.algo.ts:63
	// n = temp[1]
	frame_dig 8 // temp: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	frame_bury 4 // n: uint64

	// *if6_condition
	// contracts/lib-pcg64-ts.algo.ts:64
	// n >= threshold
	frame_dig 4 // n: uint64
	frame_dig 2 // threshold: uint64
	>=
	bz *if6_end

	// *if6_consequent
	b *while_1_end

*if6_end:
	b *while_1

*while_1_end:
	// contracts/lib-pcg64-ts.algo.ts:68
	// result.push((n % absoluteBound) + lowerBound)
	frame_dig 0 // result: uint64[]
	frame_dig 4 // n: uint64
	frame_dig 1 // absoluteBound: uint64
	%
	frame_dig -2 // lowerBound: uint64
	+
	itob
	concat
	frame_bury 0 // result: uint64[]

*for_3_continue:
	// contracts/lib-pcg64-ts.algo.ts:58
	// i = i + 1
	frame_dig 7 // i: uint64
	int 1
	+
	frame_bury 7 // i: uint64
	b *for_3

*for_3_end:

*if4_end:
	// contracts/lib-pcg64-ts.algo.ts:72
	// return [newState, result];
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0012 // initial head offset
	frame_dig 3 // newState: [uint64, uint64]
	callsub *process_static_tuple_element
	frame_dig 0 // result: uint64[]
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// bounded_rand_uint64(byte[16],uint64,uint64,uint64)uint64[]
*abi_route_bounded_rand_uint64:
	// The ABI return prefix
	byte 0x151f7c75

	// length: uint64
	txna ApplicationArgs 4
	btoi

	// upper_bound: uint64
	txna ApplicationArgs 3
	btoi

	// lower_bound: uint64
	txna ApplicationArgs 2
	btoi

	// seed: byte[16]
	txna ApplicationArgs 1
	dup
	len
	int 16
	==
	assert

	// execute bounded_rand_uint64(byte[16],uint64,uint64,uint64)uint64[]
	callsub bounded_rand_uint64
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// bounded_rand_uint64(seed: bytes<16>, lower_bound: uint64, upper_bound: uint64, length: uint64): uint64[]
bounded_rand_uint64:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/lib-pcg64-ts-exposer.algo.ts:6
	// rngState = this.pcg64Init([extractUint64(seed, 0), extractUint64(seed, 8)])
	frame_dig -1 // seed: bytes<16>
	int 0
	extract_uint64
	itob
	frame_dig -1 // seed: bytes<16>
	int 8
	extract_uint64
	itob
	concat
	callsub pcg64Init
	frame_bury 0 // rngState: (uint64,uint64)

	// contracts/lib-pcg64-ts-exposer.algo.ts:8
	// return this.pcg64Random(rngState, lower_bound, upper_bound, length)[1];
	frame_dig -4 // length: uint64
	frame_dig -3 // upper_bound: uint64
	frame_dig -2 // lower_bound: uint64
	frame_dig 0 // rngState: (uint64,uint64)
	callsub pcg64Random
	store 255 // full array
	int 16
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 8 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication
	err

*call_NoOp:
	method "bounded_rand_uint64(byte[16],uint64,uint64,uint64)uint64[]"
	txna ApplicationArgs 0
	match *abi_route_bounded_rand_uint64
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub