#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 16 6364136223846793005 1442695040888963407 1442695040888963409 4294967295
    txn NumAppArgs
    bz main___algots__.defaultCreate@10
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x5f8ae181 0xca6f4838 0x6c0b4898 // method "get_pcg64_sequence_arc4_uint64_return(byte[16],uint64,uint64,uint16)uint64[]", method "runtime_asserts_pcg64_stack_array()void", method "runtime_failure_stack_byteslice_overflow()void"
    txna ApplicationArgs 0
    match get_pcg64_sequence_arc4_uint64_return runtime_asserts_pcg64_stack_array runtime_failure_stack_byteslice_overflow
    err

main___algots__.defaultCreate@10:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_0 // 1
    return


// lib_pcg/pcg32.algo.ts::__pcg32Output(state: uint64) -> uint64:
__pcg32Output:
    proto 1 1
    frame_dig -1
    pushint 18 // 18
    shr
    frame_dig -1
    ^
    pushint 27 // 27
    shr
    intc 6 // 4294967295
    &
    frame_dig -1
    pushint 59 // 59
    shr
    dup2
    shr
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    pushint 31 // 31
    &
    uncover 2
    swap
    shl
    intc 6 // 4294967295
    &
    |
    retsub


// lib_pcg/pcg64.algo.ts::pcg64Init(seed: bytes) -> bytes:
pcg64Init:
    proto 1 1
    frame_dig -1
    len
    intc_2 // 16
    ==
    assert
    frame_dig -1
    intc_1 // 0
    extract_uint64
    intc_1 // 0
    intc_3 // 6364136223846793005
    mulw
    bury 1
    dup
    intc 4 // 1442695040888963407
    addw
    bury 1
    uncover 2
    addw
    bury 1
    intc_3 // 6364136223846793005
    mulw
    bury 1
    intc 4 // 1442695040888963407
    addw
    cover 2
    pop
    frame_dig -1
    pushint 8 // 8
    extract_uint64
    swap
    intc 5 // 1442695040888963409
    addw
    bury 1
    addw
    bury 1
    intc_3 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963409
    addw
    bury 1
    swap
    itob
    swap
    itob
    concat
    retsub


// lib_pcg/pcg64.algo.ts::pcg64Random(state: bytes, lowerBound: uint64, upperBound: uint64, length: uint64) -> bytes:
pcg64Random:
    proto 4 1
    intc_1 // 0
    pushbytes ""
    dupn 4
    frame_dig -1
    itob
    dup
    bitlen
    intc_2 // 16
    <=
    assert // overflow
    extract 6 2
    frame_dig -3
    bnz pcg64Random_else_body@6
    frame_dig -2
    bnz pcg64Random_else_body@6
    intc_1 // 0
    frame_bury 3
    frame_dig -4
    frame_bury 0

pcg64Random_while_top@3:
    frame_dig 3
    frame_dig -1
    <
    bz pcg64Random_after_if_else@19
    frame_dig 0
    callsub __pcg64UnboundedRandom
    dup
    extract 0 16
    frame_bury 0
    extract 16 8
    frame_dig 6
    swap
    concat
    frame_bury 6
    frame_dig 3
    intc_0 // 1
    +
    frame_bury 3
    b pcg64Random_while_top@3

pcg64Random_after_if_else@19:
    frame_dig -4
    pushbytes 0x0012
    concat
    frame_dig 6
    concat
    frame_bury 0
    retsub

pcg64Random_else_body@6:
    frame_dig -2
    bz pcg64Random_else_body@8
    frame_dig -2
    intc_0 // 1
    >
    assert
    frame_dig -2
    intc_0 // 1
    -
    frame_dig -3
    >
    assert
    frame_dig -2
    frame_dig -3
    -
    frame_bury 1

pcg64Random_after_if_else@9:
    frame_dig 1
    dup
    ~
    intc_0 // 1
    addw
    bury 1
    swap
    %
    frame_bury 5
    intc_1 // 0
    frame_bury 4
    frame_dig -4
    frame_bury 0

pcg64Random_while_top@10:
    frame_dig 4
    frame_dig -1
    <
    bz pcg64Random_after_if_else@19

pcg64Random_while_top@12:
    frame_dig 0
    callsub __pcg64UnboundedRandom
    dup
    extract 0 16
    frame_bury 0
    intc_2 // 16
    extract_uint64
    dup
    frame_bury 2
    frame_dig 5
    >=
    bz pcg64Random_while_top@12
    frame_dig 2
    frame_dig 1
    %
    frame_dig -3
    +
    itob
    frame_dig 6
    swap
    concat
    frame_bury 6
    frame_dig 4
    intc_0 // 1
    +
    frame_bury 4
    b pcg64Random_while_top@10

pcg64Random_else_body@8:
    frame_dig -3
    pushint 18446744073709551615 // 18446744073709551615
    <
    assert
    frame_dig -3
    itob
    pushbytes 0x010000000000000000
    swap
    b-
    btoi
    frame_bury 1
    b pcg64Random_after_if_else@9


// lib_pcg/pcg64.algo.ts::__pcg64UnboundedRandom(state: bytes) -> bytes:
__pcg64UnboundedRandom:
    proto 1 1
    frame_dig -1
    intc_1 // 0
    extract_uint64
    dup
    intc_3 // 6364136223846793005
    mulw
    bury 1
    intc 4 // 1442695040888963407
    addw
    bury 1
    frame_dig -1
    pushint 8 // 8
    extract_uint64
    dig 1
    !
    intc 5 // 1442695040888963409
    swap
    shl
    dig 1
    intc_3 // 6364136223846793005
    mulw
    bury 1
    addw
    bury 1
    uncover 2
    itob
    swap
    itob
    concat
    uncover 2
    callsub __pcg32Output
    pushint 32 // 32
    shl
    uncover 2
    callsub __pcg32Output
    |
    itob
    concat
    retsub


// smart_contracts/lib_pcg64_test_harness/contract.algo.ts::LibPcg64TestHarnessAlgoTs.get_pcg64_sequence_arc4_uint64_return[routing]() -> void:
get_pcg64_sequence_arc4_uint64_return:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 16
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 16>
    txna ApplicationArgs 2
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    pushint 2 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    callsub pcg64Init
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    btoi
    callsub pcg64Random
    dup
    intc_2 // 16
    extract_uint16
    dig 1
    len
    substring3
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts/lib_pcg64_test_harness/contract.algo.ts::LibPcg64TestHarnessAlgoTs.runtime_asserts_pcg64_stack_array[routing]() -> void:
runtime_asserts_pcg64_stack_array:
    intc_2 // 16
    bzero
    callsub pcg64Init
    intc_1 // 0
    dup
    pushint 509 // 509
    callsub pcg64Random
    pop
    intc_0 // 1
    return


// smart_contracts/lib_pcg64_test_harness/contract.algo.ts::LibPcg64TestHarnessAlgoTs.runtime_failure_stack_byteslice_overflow[routing]() -> void:
runtime_failure_stack_byteslice_overflow:
    intc_2 // 16
    bzero
    callsub pcg64Init
    intc_1 // 0
    dup
    pushint 510 // 510
    callsub pcg64Random
    pop
    intc_0 // 1
    return
