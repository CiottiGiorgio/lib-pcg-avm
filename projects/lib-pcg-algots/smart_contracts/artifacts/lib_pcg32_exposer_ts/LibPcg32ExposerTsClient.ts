/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { AlgorandClientInterface } from '@algorandfoundation/algokit-utils/types/algorand-client-interface'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'
import SimulateResponse = modelsv2.SimulateResponse

export const APP_SPEC: Arc56Contract = {"name":"LibPcg32ExposerTs","structs":{},"methods":[{"name":"bounded_rand_uint32","args":[{"type":"byte[8]","name":"seed"},{"type":"uint32","name":"lower_bound"},{"type":"uint32","name":"upper_bound"},{"type":"uint16","name":"length"}],"returns":{"type":"uint32[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"bounded_rand_uint16","args":[{"type":"byte[8]","name":"seed"},{"type":"uint16","name":"lower_bound"},{"type":"uint16","name":"upper_bound"},{"type":"uint16","name":"length"}],"returns":{"type":"uint16[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"bounded_rand_uint8","args":[{"type":"byte[8]","name":"seed"},{"type":"uint8","name":"lower_bound"},{"type":"uint8","name":"upper_bound"},{"type":"uint16","name":"length"}],"returns":{"type":"uint8[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"update","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}}],"arcs":[22,28],"networks":{},"state":{"schema":{"global":{"ints":0,"bytes":0},"local":{"ints":0,"bytes":0}},"keys":{"global":{},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{}}},"bareActions":{"create":["NoOp"],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[78,106,134,162],"errorMessage":"OnCompletion is not NoOp"},{"pc":[179],"errorMessage":"can only call when creating"},{"pc":[81,109,137,165],"errorMessage":"can only call when not creating"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czo6TGliUGNnMzJFeHBvc2VyVHMuYXBwcm92YWxQcm9ncmFtOgogICAgaW50Y2Jsb2NrIDEgMCAyIDggMTQ0MjY5NTA0MDg4ODk2MzQwNwogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1IDB4MDAwMAogICAgY2FsbHN1YiBfX3B1eWFfYXJjNF9yb3V0ZXJfXwogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6OkxpYlBjZzMyRXhwb3NlclRzLl9fcHV5YV9hcmM0X3JvdXRlcl9fKCkgLT4gdWludDY0OgpfX3B1eWFfYXJjNF9yb3V0ZXJfXzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9saWJfcGNnMzJfZXhwb3Nlcl90cy9jb250cmFjdC5hbGdvLnRzOjUKICAgIC8vIGV4cG9ydCBjbGFzcyBMaWJQY2czMkV4cG9zZXJUcyBleHRlbmRzIENvbnRyYWN0IHsKICAgIHByb3RvIDAgMQogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2JhcmVfcm91dGluZ0A4CiAgICBwdXNoYnl0ZXNzIDB4ZWQwNmY3MGEgMHg4ZDdjY2U3OSAweGQwYTM1ZTFlIDB4YTBlODE4NzIgLy8gbWV0aG9kICJib3VuZGVkX3JhbmRfdWludDMyKGJ5dGVbOF0sdWludDMyLHVpbnQzMix1aW50MTYpdWludDMyW10iLCBtZXRob2QgImJvdW5kZWRfcmFuZF91aW50MTYoYnl0ZVs4XSx1aW50MTYsdWludDE2LHVpbnQxNil1aW50MTZbXSIsIG1ldGhvZCAiYm91bmRlZF9yYW5kX3VpbnQ4KGJ5dGVbOF0sdWludDgsdWludDgsdWludDE2KXVpbnQ4W10iLCBtZXRob2QgInVwZGF0ZSgpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2JvdW5kZWRfcmFuZF91aW50MzJfcm91dGVAMiBfX3B1eWFfYXJjNF9yb3V0ZXJfX19ib3VuZGVkX3JhbmRfdWludDE2X3JvdXRlQDMgX19wdXlhX2FyYzRfcm91dGVyX19fYm91bmRlZF9yYW5kX3VpbnQ4X3JvdXRlQDQgX19wdXlhX2FyYzRfcm91dGVyX19fdXBkYXRlX3JvdXRlQDUKICAgIGludGNfMSAvLyAwCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2JvdW5kZWRfcmFuZF91aW50MzJfcm91dGVAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9saWJfcGNnMzJfZXhwb3Nlcl90cy9jb250cmFjdC5hbGdvLnRzOjYtMTEKICAgIC8vIGJvdW5kZWRfcmFuZF91aW50MzIoCiAgICAvLyAgIHNlZWQ6IFN0YXRpY0FycmF5PEJ5dGUsIDg+LAogICAgLy8gICBsb3dlcl9ib3VuZDogVWludE48MzI+LAogICAgLy8gICB1cHBlcl9ib3VuZDogVWludE48MzI+LAogICAgLy8gICBsZW5ndGg6IFVpbnROPDE2PgogICAgLy8gKTogRHluYW1pY0FycmF5PFVpbnROPDMyPj4gewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czo1CiAgICAvLyBleHBvcnQgY2xhc3MgTGliUGNnMzJFeHBvc2VyVHMgZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czo2LTExCiAgICAvLyBib3VuZGVkX3JhbmRfdWludDMyKAogICAgLy8gICBzZWVkOiBTdGF0aWNBcnJheTxCeXRlLCA4PiwKICAgIC8vICAgbG93ZXJfYm91bmQ6IFVpbnROPDMyPiwKICAgIC8vICAgdXBwZXJfYm91bmQ6IFVpbnROPDMyPiwKICAgIC8vICAgbGVuZ3RoOiBVaW50TjwxNj4KICAgIC8vICk6IER5bmFtaWNBcnJheTxVaW50TjwzMj4+IHsKICAgIGNhbGxzdWIgYm91bmRlZF9yYW5kX3VpbnQzMgogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYm91bmRlZF9yYW5kX3VpbnQxNl9yb3V0ZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6MjAtMjUKICAgIC8vIGJvdW5kZWRfcmFuZF91aW50MTYoCiAgICAvLyAgIHNlZWQ6IFN0YXRpY0FycmF5PEJ5dGUsIDg+LAogICAgLy8gICBsb3dlcl9ib3VuZDogVWludE48MTY+LAogICAgLy8gICB1cHBlcl9ib3VuZDogVWludE48MTY+LAogICAgLy8gICBsZW5ndGg6IFVpbnROPDE2PgogICAgLy8gKTogRHluYW1pY0FycmF5PFVpbnROPDE2Pj4gewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czo1CiAgICAvLyBleHBvcnQgY2xhc3MgTGliUGNnMzJFeHBvc2VyVHMgZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czoyMC0yNQogICAgLy8gYm91bmRlZF9yYW5kX3VpbnQxNigKICAgIC8vICAgc2VlZDogU3RhdGljQXJyYXk8Qnl0ZSwgOD4sCiAgICAvLyAgIGxvd2VyX2JvdW5kOiBVaW50TjwxNj4sCiAgICAvLyAgIHVwcGVyX2JvdW5kOiBVaW50TjwxNj4sCiAgICAvLyAgIGxlbmd0aDogVWludE48MTY+CiAgICAvLyApOiBEeW5hbWljQXJyYXk8VWludE48MTY+PiB7CiAgICBjYWxsc3ViIGJvdW5kZWRfcmFuZF91aW50MTYKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2JvdW5kZWRfcmFuZF91aW50OF9yb3V0ZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6MzQtMzkKICAgIC8vIGJvdW5kZWRfcmFuZF91aW50OCgKICAgIC8vICAgc2VlZDogU3RhdGljQXJyYXk8Qnl0ZSwgOD4sCiAgICAvLyAgIGxvd2VyX2JvdW5kOiBVaW50Tjw4PiwKICAgIC8vICAgdXBwZXJfYm91bmQ6IFVpbnROPDg+LAogICAgLy8gICBsZW5ndGg6IFVpbnROPDE2PgogICAgLy8gKTogRHluYW1pY0FycmF5PFVpbnROPDg+PiB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9saWJfcGNnMzJfZXhwb3Nlcl90cy9jb250cmFjdC5hbGdvLnRzOjUKICAgIC8vIGV4cG9ydCBjbGFzcyBMaWJQY2czMkV4cG9zZXJUcyBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9saWJfcGNnMzJfZXhwb3Nlcl90cy9jb250cmFjdC5hbGdvLnRzOjM0LTM5CiAgICAvLyBib3VuZGVkX3JhbmRfdWludDgoCiAgICAvLyAgIHNlZWQ6IFN0YXRpY0FycmF5PEJ5dGUsIDg+LAogICAgLy8gICBsb3dlcl9ib3VuZDogVWludE48OD4sCiAgICAvLyAgIHVwcGVyX2JvdW5kOiBVaW50Tjw4PiwKICAgIC8vICAgbGVuZ3RoOiBVaW50TjwxNj4KICAgIC8vICk6IER5bmFtaWNBcnJheTxVaW50Tjw4Pj4gewogICAgY2FsbHN1YiBib3VuZGVkX3JhbmRfdWludDgKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX3VwZGF0ZV9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6NDkKICAgIC8vIHVwZGF0ZSgpIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB1cGRhdGUKICAgIGludGNfMCAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2JhcmVfcm91dGluZ0A4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6NQogICAgLy8gZXhwb3J0IGNsYXNzIExpYlBjZzMyRXhwb3NlclRzIGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgYm56IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2FmdGVyX2lmX2Vsc2VAMTIKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZnRlcl9pZl9lbHNlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6NQogICAgLy8gZXhwb3J0IGNsYXNzIExpYlBjZzMyRXhwb3NlclRzIGV4dGVuZHMgQ29udHJhY3QgewogICAgaW50Y18xIC8vIDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9saWJfcGNnMzJfZXhwb3Nlcl90cy9jb250cmFjdC5hbGdvLnRzOjpMaWJQY2czMkV4cG9zZXJUcy5ib3VuZGVkX3JhbmRfdWludDMyKHNlZWQ6IGJ5dGVzLCBsb3dlcl9ib3VuZDogYnl0ZXMsIHVwcGVyX2JvdW5kOiBieXRlcywgbGVuZ3RoOiBieXRlcykgLT4gYnl0ZXM6CmJvdW5kZWRfcmFuZF91aW50MzI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czo2LTExCiAgICAvLyBib3VuZGVkX3JhbmRfdWludDMyKAogICAgLy8gICBzZWVkOiBTdGF0aWNBcnJheTxCeXRlLCA4PiwKICAgIC8vICAgbG93ZXJfYm91bmQ6IFVpbnROPDMyPiwKICAgIC8vICAgdXBwZXJfYm91bmQ6IFVpbnROPDMyPiwKICAgIC8vICAgbGVuZ3RoOiBVaW50TjwxNj4KICAgIC8vICk6IER5bmFtaWNBcnJheTxVaW50TjwzMj4+IHsKICAgIHByb3RvIDQgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6MTIKICAgIC8vIGNvbnN0IHN0YXRlID0gcGNnMzJJbml0KHNlZWQuYnl0ZXMpOwogICAgZnJhbWVfZGlnIC00CiAgICBjYWxsc3ViIHBjZzMySW5pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6MTUKICAgIC8vIGNvbnN0IFtuZXdTdGF0ZSwgc2VxdWVuY2VdID0gcGNnMzJSYW5kb20oc3RhdGUsIGxvd2VyX2JvdW5kLm5hdGl2ZSwgdXBwZXJfYm91bmQubmF0aXZlLCBsZW5ndGgubmF0aXZlKTsKICAgIGZyYW1lX2RpZyAtMwogICAgYnRvaQogICAgZnJhbWVfZGlnIC0yCiAgICBidG9pCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ0b2kKICAgIGNhbGxzdWIgcGNnMzJSYW5kb20KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6MTcKICAgIC8vIHJldHVybiBzZXF1ZW5jZTsKICAgIHJldHN1YgoKCi8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo6cGNnMzJJbml0KHNlZWQ6IGJ5dGVzKSAtPiB1aW50NjQ6CnBjZzMySW5pdDoKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo5OQogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHBjZzMySW5pdChzZWVkOiBieXRlcyk6IFBDRzMyU1RBVEUgewogICAgcHJvdG8gMSAxCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTAwCiAgICAvLyBhc3NlcnQoc2VlZC5sZW5ndGggPT09IDgpOwogICAgZnJhbWVfZGlnIC0xCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTAyCiAgICAvLyByZXR1cm4gX19wY2czMkluaXQob3AuYnRvaShzZWVkKSwgcGNnRmlyc3RJbmNyZW1lbnQpOwogICAgZnJhbWVfZGlnIC0xCiAgICBidG9pCiAgICAvLyBsaWJfcGNnL2NvbnN0cy5hbGdvLnRzOjYKICAgIC8vIGV4cG9ydCBjb25zdCBwY2dGaXJzdEluY3JlbWVudCA9IFVpbnQ2NCgxNDQyNjk1MDQwODg4OTYzNDA3bik7CiAgICBpbnRjIDQgLy8gMTQ0MjY5NTA0MDg4ODk2MzQwNwogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjEwMgogICAgLy8gcmV0dXJuIF9fcGNnMzJJbml0KG9wLmJ0b2koc2VlZCksIHBjZ0ZpcnN0SW5jcmVtZW50KTsKICAgIGNhbGxzdWIgX19wY2czMkluaXQKICAgIHJldHN1YgoKCi8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo6X19wY2czMkluaXQoaW5pdGlhbFN0YXRlOiB1aW50NjQsIGluY3I6IHVpbnQ2NCkgLT4gdWludDY0OgpfX3BjZzMySW5pdDoKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo5MgogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIF9fcGNnMzJJbml0KGluaXRpYWxTdGF0ZTogUENHMzJTVEFURSwgaW5jcjogdWludDY0KTogUENHMzJTVEFURSB7CiAgICBwcm90byAyIDEKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo5MwogICAgLy8gY29uc3Qgc3RhdGUgPSBfX3BjZzMyU3RlcCgwLCBpbmNyKTsKICAgIGludGNfMSAvLyAwCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX19wY2czMlN0ZXAKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo5NAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcoc3RhdGUsIGluaXRpYWxTdGF0ZSk7CiAgICBmcmFtZV9kaWcgLTIKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjk2CiAgICAvLyByZXR1cm4gX19wY2czMlN0ZXAoYWRkTG93LCBpbmNyKTsKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfX3BjZzMyU3RlcAogICAgcmV0c3ViCgoKLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjpfX3BjZzMyU3RlcChzdGF0ZTogdWludDY0LCBpbmNyOiB1aW50NjQpIC0+IHVpbnQ2NDoKX19wY2czMlN0ZXA6CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTYKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBfX3BjZzMyU3RlcChzdGF0ZTogUENHMzJTVEFURSwgaW5jcjogdWludDY0KTogdWludDY0IHsKICAgIHByb3RvIDIgMQogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjE3CiAgICAvLyBjb25zdCBbLCBtdWxMb3ddID0gb3AubXVsdyhzdGF0ZSwgcGNnTXVsdGlwbGllcik7CiAgICBmcmFtZV9kaWcgLTIKICAgIC8vIGxpYl9wY2cvY29uc3RzLmFsZ28udHM6NAogICAgLy8gZXhwb3J0IGNvbnN0IHBjZ011bHRpcGxpZXIgPSBVaW50NjQoNjM2NDEzNjIyMzg0Njc5MzAwNW4pOwogICAgcHVzaGludCA2MzY0MTM2MjIzODQ2NzkzMDA1IC8vIDYzNjQxMzYyMjM4NDY3OTMwMDUKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxNwogICAgLy8gY29uc3QgWywgbXVsTG93XSA9IG9wLm11bHcoc3RhdGUsIHBjZ011bHRpcGxpZXIpOwogICAgbXVsdwogICAgYnVyeSAxCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTgKICAgIC8vIGNvbnN0IFssIGFkZExvd10gPSBvcC5hZGR3KG11bExvdywgaW5jcik7CiAgICBmcmFtZV9kaWcgLTEKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjIwCiAgICAvLyByZXR1cm4gYWRkTG93OwogICAgcmV0c3ViCgoKLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjpwY2czMlJhbmRvbShzdGF0ZTogdWludDY0LCBsb3dlckJvdW5kOiB1aW50NjQsIHVwcGVyQm91bmQ6IHVpbnQ2NCwgbGVuZ3RoOiB1aW50NjQpIC0+IHVpbnQ2NCwgYnl0ZXM6CnBjZzMyUmFuZG9tOgogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjExMy0xMTgKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBwY2czMlJhbmRvbSgKICAgIC8vICAgc3RhdGU6IFBDRzMyU1RBVEUsCiAgICAvLyAgIGxvd2VyQm91bmQ6IHVpbnQ2NCwKICAgIC8vICAgdXBwZXJCb3VuZDogdWludDY0LAogICAgLy8gICBsZW5ndGg6IHVpbnQ2NAogICAgLy8gKTogW1BDRzMyU1RBVEUsIER5bmFtaWNBcnJheTxVaW50TjwzMj4+XSB7CiAgICBwcm90byA0IDIKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxMTkKICAgIC8vIGNvbnN0IHJlc3VsdCA9IG5ldyBEeW5hbWljQXJyYXk8VWludE48MzI+PigpOwogICAgYnl0ZWNfMSAvLyAweDAwMDAKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxMjAKICAgIC8vIGNvbnN0IFtuZXdTdGF0ZSwgc2VxdWVuY2VdID0gX19wY2czMkJvdW5kZWRTZXF1ZW5jZShzdGF0ZSwgMzIsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIGxlbmd0aCk7CiAgICBmcmFtZV9kaWcgLTQKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGZyYW1lX2RpZyAtMwogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX19wY2czMkJvdW5kZWRTZXF1ZW5jZQogICAgc3dhcAogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjEyMwogICAgLy8gZm9yIChsZXQgaSA9IFVpbnQ2NCgwKTsgaSA8IGxlbmd0aDsgaSA9IGkgKyAxKSB7CiAgICBpbnRjXzEgLy8gMAoKcGNnMzJSYW5kb21fd2hpbGVfdG9wQDE6CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTIzCiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTEKICAgIDwKICAgIGJ6IHBjZzMyUmFuZG9tX2FmdGVyX3doaWxlQDQKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxMjQKICAgIC8vIHJlc3VsdC5wdXNoKG5ldyBVaW50TjwzMj4ob3AuZXh0cmFjdFVpbnQzMihzZXF1ZW5jZSwgMiArIGkgKiA0KSkpOwogICAgZnJhbWVfZGlnIDAKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBwdXNoaW50IDQgLy8gNAogICAgKgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGZyYW1lX2RpZyAxCiAgICBzd2FwCiAgICBleHRyYWN0X3VpbnQzMgogICAgaXRvYgogICAgZXh0cmFjdCA0IDQKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgNCAvLyA0CiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxMjMKICAgIC8vIGZvciAobGV0IGkgPSBVaW50NjQoMCk7IGkgPCBsZW5ndGg7IGkgPSBpICsgMSkgewogICAgaW50Y18wIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMwogICAgYiBwY2czMlJhbmRvbV93aGlsZV90b3BAMQoKcGNnMzJSYW5kb21fYWZ0ZXJfd2hpbGVANDoKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxMjcKICAgIC8vIHJldHVybiBbbmV3U3RhdGUsIHJlc3VsdC5jb3B5KCldOwogICAgZnJhbWVfZGlnIDIKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjpfX3BjZzMyQm91bmRlZFNlcXVlbmNlKHN0YXRlOiB1aW50NjQsIGJpdFNpemU6IHVpbnQ2NCwgbG93ZXJCb3VuZDogdWludDY0LCB1cHBlckJvdW5kOiB1aW50NjQsIGxlbmd0aDogdWludDY0KSAtPiB1aW50NjQsIGJ5dGVzOgpfX3BjZzMyQm91bmRlZFNlcXVlbmNlOgogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjMzLTM5CiAgICAvLyBmdW5jdGlvbiBfX3BjZzMyQm91bmRlZFNlcXVlbmNlKAogICAgLy8gICBzdGF0ZTogUENHMzJTVEFURSwKICAgIC8vICAgYml0U2l6ZTogdWludDY0LAogICAgLy8gICBsb3dlckJvdW5kOiB1aW50NjQsCiAgICAvLyAgIHVwcGVyQm91bmQ6IHVpbnQ2NCwKICAgIC8vICAgbGVuZ3RoOiB1aW50NjQKICAgIC8vICk6IFtQQ0czMlNUQVRFLCBieXRlc10gewogICAgcHJvdG8gNSAyCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gNgogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjQyCiAgICAvLyBhc3NlcnQobGVuZ3RoIDwgb3Auc2hsKDEsIDE2KSk7CiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hpbnQgNjU1MzYgLy8gNjU1MzYKICAgIDwKICAgIGFzc2VydAogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjQzCiAgICAvLyByZXN1bHQgPSBuZXcgVWludE48MTY+KGxlbmd0aCkuYnl0ZXM7CiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6NDUKICAgIC8vIGFzc2VydChiaXRTaXplID09PSA4IHx8IGJpdFNpemUgPT09IDE2IHx8IGJpdFNpemUgPT09IDMyKTsKICAgIGZyYW1lX2RpZyAtNAogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBibnogX19wY2czMkJvdW5kZWRTZXF1ZW5jZV9ib29sX3RydWVAMwogICAgZnJhbWVfZGlnIC00CiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICA9PQogICAgYm56IF9fcGNnMzJCb3VuZGVkU2VxdWVuY2VfYm9vbF90cnVlQDMKICAgIGZyYW1lX2RpZyAtNAogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGJ6IF9fcGNnMzJCb3VuZGVkU2VxdWVuY2VfYm9vbF9mYWxzZUA0CgpfX3BjZzMyQm91bmRlZFNlcXVlbmNlX2Jvb2xfdHJ1ZUAzOgogICAgaW50Y18wIC8vIDEKICAgIGIgX19wY2czMkJvdW5kZWRTZXF1ZW5jZV9ib29sX21lcmdlQDUKCl9fcGNnMzJCb3VuZGVkU2VxdWVuY2VfYm9vbF9mYWxzZUA0OgogICAgaW50Y18xIC8vIDAKCl9fcGNnMzJCb3VuZGVkU2VxdWVuY2VfYm9vbF9tZXJnZUA1OgogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjQ1CiAgICAvLyBhc3NlcnQoYml0U2l6ZSA9PT0gOCB8fCBiaXRTaXplID09PSAxNiB8fCBiaXRTaXplID09PSAzMik7CiAgICBhc3NlcnQKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo0NgogICAgLy8gY29uc3QgYnl0ZVNpemUgPSBvcC5zaHIoYml0U2l6ZSwgMyk7CiAgICBmcmFtZV9kaWcgLTQKICAgIHB1c2hpbnQgMyAvLyAzCiAgICBzaHIKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6NDcKICAgIC8vIGNvbnN0IHRydW5jYXRlZFN0YXJ0Q2FjaGVkOiB1aW50NjQgPSBVaW50NjQoOCkgLSBieXRlU2l6ZTsKICAgIGludGNfMyAvLyA4CiAgICBzd2FwCiAgICAtCiAgICBmcmFtZV9idXJ5IDYKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo1MQogICAgLy8gaWYgKGxvd2VyQm91bmQgPT09IDAgJiYgdXBwZXJCb3VuZCA9PT0gMCkgewogICAgZnJhbWVfZGlnIC0zCiAgICBibnogX19wY2czMkJvdW5kZWRTZXF1ZW5jZV9lbHNlX2JvZHlAMTMKICAgIGZyYW1lX2RpZyAtMgogICAgYm56IF9fcGNnMzJCb3VuZGVkU2VxdWVuY2VfZWxzZV9ib2R5QDEzCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6NTIKICAgIC8vIGZvciAobGV0IGkgPSBVaW50NjQoMCk7IGkgPCBsZW5ndGg7IGkgPSBpICsgMSkgewogICAgaW50Y18xIC8vIDAKICAgIGZyYW1lX2J1cnkgMwoKX19wY2czMkJvdW5kZWRTZXF1ZW5jZV93aGlsZV90b3BAODoKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo1MgogICAgLy8gZm9yIChsZXQgaSA9IFVpbnQ2NCgwKTsgaSA8IGxlbmd0aDsgaSA9IGkgKyAxKSB7CiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfZGlnIC0xCiAgICA8CiAgICBieiBfX3BjZzMyQm91bmRlZFNlcXVlbmNlX2FmdGVyX2lmX2Vsc2VAMjkKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo1MwogICAgLy8gY29uc3QgW25ld1N0YXRlLCBuXSA9IF9fcGNnMzJVbmJvdW5kZWRSYW5kb20oc3RhdGUpOwogICAgZnJhbWVfZGlnIC01CiAgICBjYWxsc3ViIF9fcGNnMzJVbmJvdW5kZWRSYW5kb20KICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo1NgogICAgLy8gcmVzdWx0ID0gb3AuY29uY2F0KHJlc3VsdCwgb3AuZXh0cmFjdChvcC5pdG9iKG4pLCB0cnVuY2F0ZWRTdGFydENhY2hlZCwgYnl0ZVNpemUpKTsKICAgIGl0b2IKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9kaWcgMQogICAgZXh0cmFjdDMKICAgIGZyYW1lX2RpZyA3CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgNwogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjUyCiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIGZyYW1lX2RpZyAzCiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAzCiAgICBmcmFtZV9idXJ5IC01CiAgICBiIF9fcGNnMzJCb3VuZGVkU2VxdWVuY2Vfd2hpbGVfdG9wQDgKCl9fcGNnMzJCb3VuZGVkU2VxdWVuY2VfZWxzZV9ib2R5QDEzOgogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjU5CiAgICAvLyBpZiAodXBwZXJCb3VuZCAhPT0gMCkgewogICAgZnJhbWVfZGlnIC0yCiAgICBieiBfX3BjZzMyQm91bmRlZFNlcXVlbmNlX2Vsc2VfYm9keUAxNQogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjYwCiAgICAvLyBhc3NlcnQodXBwZXJCb3VuZCA+IDEpOwogICAgZnJhbWVfZGlnIC0yCiAgICBpbnRjXzAgLy8gMQogICAgPgogICAgYXNzZXJ0CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6NjEKICAgIC8vIGFzc2VydCh1cHBlckJvdW5kIDwgb3Auc2hsKDEsIGJpdFNpemUpKTsKICAgIGludGNfMCAvLyAxCiAgICBmcmFtZV9kaWcgLTQKICAgIHNobAogICAgZnJhbWVfZGlnIC0yCiAgICA+CiAgICBhc3NlcnQKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo2MgogICAgLy8gYXNzZXJ0KGxvd2VyQm91bmQgPCB1cHBlckJvdW5kIC0gMSk7CiAgICBmcmFtZV9kaWcgLTIKICAgIGludGNfMCAvLyAxCiAgICAtCiAgICBmcmFtZV9kaWcgLTMKICAgID4KICAgIGFzc2VydAogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjY0CiAgICAvLyBhYnNvbHV0ZUJvdW5kID0gdXBwZXJCb3VuZCAtIGxvd2VyQm91bmQ7CiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMwogICAgLQogICAgZnJhbWVfYnVyeSAwCiAgICBiIF9fcGNnMzJCb3VuZGVkU2VxdWVuY2VfYWZ0ZXJfaWZfZWxzZUAxNgoKX19wY2czMkJvdW5kZWRTZXF1ZW5jZV9lbHNlX2JvZHlAMTU6CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6NjYKICAgIC8vIGFzc2VydChsb3dlckJvdW5kIDwgb3Auc2hsKDEsIGJpdFNpemUpIC0gMSk7CiAgICBpbnRjXzAgLy8gMQogICAgZnJhbWVfZGlnIC00CiAgICBzaGwKICAgIGR1cAogICAgaW50Y18wIC8vIDEKICAgIC0KICAgIGZyYW1lX2RpZyAtMwogICAgPgogICAgYXNzZXJ0CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6NjgKICAgIC8vIGFic29sdXRlQm91bmQgPSBvcC5zaGwoMSwgYml0U2l6ZSkgLSBsb3dlckJvdW5kOwogICAgZnJhbWVfZGlnIC0zCiAgICAtCiAgICBmcmFtZV9idXJ5IDAKCl9fcGNnMzJCb3VuZGVkU2VxdWVuY2VfYWZ0ZXJfaWZfZWxzZUAxNjoKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo3MQogICAgLy8gY29uc3QgdGhyZXNob2xkOiB1aW50NjQgPSBfX21hc2tUb1VpbnQzMihfX3VpbnQ2NFR3b3MoYWJzb2x1dGVCb3VuZCkpICUgYWJzb2x1dGVCb3VuZDsKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGNhbGxzdWIgX191aW50NjRUd29zCiAgICBjYWxsc3ViIF9fbWFza1RvVWludDMyCiAgICBzd2FwCiAgICAlCiAgICBmcmFtZV9idXJ5IDUKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo3MwogICAgLy8gZm9yIChsZXQgaSA9IFVpbnQ2NCgwKTsgaSA8IGxlbmd0aDsgaSA9IGkgKyAxKSB7CiAgICBpbnRjXzEgLy8gMAogICAgZnJhbWVfYnVyeSA0CgpfX3BjZzMyQm91bmRlZFNlcXVlbmNlX3doaWxlX3RvcEAxNzoKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo3MwogICAgLy8gZm9yIChsZXQgaSA9IFVpbnQ2NCgwKTsgaSA8IGxlbmd0aDsgaSA9IGkgKyAxKSB7CiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfZGlnIC0xCiAgICA8CiAgICBieiBfX3BjZzMyQm91bmRlZFNlcXVlbmNlX2FmdGVyX2lmX2Vsc2VAMjkKCl9fcGNnMzJCb3VuZGVkU2VxdWVuY2Vfd2hpbGVfdG9wQDE5OgogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjc2CiAgICAvLyBjb25zdCBbbmV3U3RhdGUsIGNhbmRpZGF0ZV0gPSBfX3BjZzMyVW5ib3VuZGVkUmFuZG9tKHN0YXRlKTsKICAgIGZyYW1lX2RpZyAtNQogICAgY2FsbHN1YiBfX3BjZzMyVW5ib3VuZGVkUmFuZG9tCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgMgogICAgc3dhcAogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjc4CiAgICAvLyBpZiAoY2FuZGlkYXRlID49IHRocmVzaG9sZCkgewogICAgZnJhbWVfZGlnIDUKICAgID49CiAgICBieiBfX3BjZzMyQm91bmRlZFNlcXVlbmNlX2FmdGVyX2lmX2Vsc2VAMjIKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo4MQogICAgLy8gb3AuZXh0cmFjdChvcC5pdG9iKChjYW5kaWRhdGUgJSBhYnNvbHV0ZUJvdW5kKSArIGxvd2VyQm91bmQpLCB0cnVuY2F0ZWRTdGFydENhY2hlZCwgYnl0ZVNpemUpCiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIDAKICAgICUKICAgIGZyYW1lX2RpZyAtMwogICAgKwogICAgaXRvYgogICAgZnJhbWVfZGlnIDYKICAgIGZyYW1lX2RpZyAxCiAgICBleHRyYWN0MwogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjc5LTgyCiAgICAvLyByZXN1bHQgPSBvcC5jb25jYXQoCiAgICAvLyAgIHJlc3VsdCwKICAgIC8vICAgb3AuZXh0cmFjdChvcC5pdG9iKChjYW5kaWRhdGUgJSBhYnNvbHV0ZUJvdW5kKSArIGxvd2VyQm91bmQpLCB0cnVuY2F0ZWRTdGFydENhY2hlZCwgYnl0ZVNpemUpCiAgICAvLyApOwogICAgZnJhbWVfZGlnIDcKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSA3CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6NzMKICAgIC8vIGZvciAobGV0IGkgPSBVaW50NjQoMCk7IGkgPCBsZW5ndGg7IGkgPSBpICsgMSkgewogICAgZnJhbWVfZGlnIDQKICAgIGludGNfMCAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDQKICAgIGZyYW1lX2J1cnkgLTUKICAgIGIgX19wY2czMkJvdW5kZWRTZXF1ZW5jZV93aGlsZV90b3BAMTcKCl9fcGNnMzJCb3VuZGVkU2VxdWVuY2VfYWZ0ZXJfaWZfZWxzZUAyMjoKICAgIGZyYW1lX2J1cnkgLTUKICAgIGIgX19wY2czMkJvdW5kZWRTZXF1ZW5jZV93aGlsZV90b3BAMTkKCl9fcGNnMzJCb3VuZGVkU2VxdWVuY2VfYWZ0ZXJfaWZfZWxzZUAyOToKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo4OQogICAgLy8gcmV0dXJuIFtzdGF0ZSwgcmVzdWx0XTsKICAgIGZyYW1lX2RpZyAtNQogICAgZnJhbWVfZGlnIDcKICAgIGZyYW1lX2J1cnkgMQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6Ol9fcGNnMzJVbmJvdW5kZWRSYW5kb20oc3RhdGU6IHVpbnQ2NCkgLT4gdWludDY0LCB1aW50NjQ6Cl9fcGNnMzJVbmJvdW5kZWRSYW5kb206CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MjkKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBfX3BjZzMyVW5ib3VuZGVkUmFuZG9tKHN0YXRlOiBQQ0czMlNUQVRFKTogW1BDRzMyU1RBVEUsIHVpbnQ2NF0gewogICAgcHJvdG8gMSAyCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MzAKICAgIC8vIHJldHVybiBbX19wY2czMlN0ZXAoc3RhdGUsIHBjZ0ZpcnN0SW5jcmVtZW50KSwgX19wY2czMk91dHB1dChzdGF0ZSldOwogICAgZnJhbWVfZGlnIC0xCiAgICAvLyBsaWJfcGNnL2NvbnN0cy5hbGdvLnRzOjYKICAgIC8vIGV4cG9ydCBjb25zdCBwY2dGaXJzdEluY3JlbWVudCA9IFVpbnQ2NCgxNDQyNjk1MDQwODg4OTYzNDA3bik7CiAgICBpbnRjIDQgLy8gMTQ0MjY5NTA0MDg4ODk2MzQwNwogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjMwCiAgICAvLyByZXR1cm4gW19fcGNnMzJTdGVwKHN0YXRlLCBwY2dGaXJzdEluY3JlbWVudCksIF9fcGNnMzJPdXRwdXQoc3RhdGUpXTsKICAgIGNhbGxzdWIgX19wY2czMlN0ZXAKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBfX3BjZzMyT3V0cHV0CiAgICByZXRzdWIKCgovLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6Ol9fcGNnMzJPdXRwdXQoc3RhdGU6IHVpbnQ2NCkgLT4gdWludDY0OgpfX3BjZzMyT3V0cHV0OgogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjIzCiAgICAvLyBleHBvcnQgZnVuY3Rpb24gX19wY2czMk91dHB1dChzdGF0ZTogUENHMzJTVEFURSk6IHVpbnQ2NCB7CiAgICBwcm90byAxIDEKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoyNAogICAgLy8gY29uc3QgeG9yc2hpZnRlZCA9IF9fbWFza1RvVWludDMyKG9wLnNocihvcC5zaHIoc3RhdGUsIDE4KSBeIHN0YXRlLCAyNykpOwogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDE4IC8vIDE4CiAgICBzaHIKICAgIGZyYW1lX2RpZyAtMQogICAgXgogICAgcHVzaGludCAyNyAvLyAyNwogICAgc2hyCiAgICBjYWxsc3ViIF9fbWFza1RvVWludDMyCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MjUKICAgIC8vIGNvbnN0IHJvdCA9IG9wLnNocihzdGF0ZSwgNTkpOwogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDU5IC8vIDU5CiAgICBzaHIKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoyNgogICAgLy8gcmV0dXJuIG9wLnNocih4b3JzaGlmdGVkLCByb3QpIHwgX19tYXNrVG9VaW50MzIob3Auc2hsKHhvcnNoaWZ0ZWQsIF9fdWludDY0VHdvcyhyb3QpICYgMzEpKTsKICAgIGR1cDIKICAgIHNocgogICAgc3dhcAogICAgY2FsbHN1YiBfX3VpbnQ2NFR3b3MKICAgIHB1c2hpbnQgMzEgLy8gMzEKICAgICYKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgc2hsCiAgICBjYWxsc3ViIF9fbWFza1RvVWludDMyCiAgICB8CiAgICByZXRzdWIKCgovLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6Ol9fbWFza1RvVWludDMyKHZhbHVlOiB1aW50NjQpIC0+IHVpbnQ2NDoKX19tYXNrVG9VaW50MzI6CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTIKICAgIC8vIGZ1bmN0aW9uIF9fbWFza1RvVWludDMyKHZhbHVlOiB1aW50NjQpOiB1aW50NjQgewogICAgcHJvdG8gMSAxCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTMKICAgIC8vIHJldHVybiB2YWx1ZSAmIChvcC5zaGwoMSwgMzIpIC0gMSk7CiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hpbnQgNDI5NDk2NzI5NSAvLyA0Mjk0OTY3Mjk1CiAgICAmCiAgICByZXRzdWIKCgovLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6Ol9fdWludDY0VHdvcyh2YWx1ZTogdWludDY0KSAtPiB1aW50NjQ6Cl9fdWludDY0VHdvczoKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czo3CiAgICAvLyBleHBvcnQgZnVuY3Rpb24gX191aW50NjRUd29zKHZhbHVlOiB1aW50NjQpOiB1aW50NjQgewogICAgcHJvdG8gMSAxCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6OAogICAgLy8gY29uc3QgWywgYWRkTG93XSA9IG9wLmFkZHcofnZhbHVlLCAxKTsKICAgIGZyYW1lX2RpZyAtMQogICAgfgogICAgaW50Y18wIC8vIDEKICAgIGFkZHcKICAgIGJ1cnkgMQogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjkKICAgIC8vIHJldHVybiBhZGRMb3c7CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czo6TGliUGNnMzJFeHBvc2VyVHMuYm91bmRlZF9yYW5kX3VpbnQxNihzZWVkOiBieXRlcywgbG93ZXJfYm91bmQ6IGJ5dGVzLCB1cHBlcl9ib3VuZDogYnl0ZXMsIGxlbmd0aDogYnl0ZXMpIC0+IGJ5dGVzOgpib3VuZGVkX3JhbmRfdWludDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6MjAtMjUKICAgIC8vIGJvdW5kZWRfcmFuZF91aW50MTYoCiAgICAvLyAgIHNlZWQ6IFN0YXRpY0FycmF5PEJ5dGUsIDg+LAogICAgLy8gICBsb3dlcl9ib3VuZDogVWludE48MTY+LAogICAgLy8gICB1cHBlcl9ib3VuZDogVWludE48MTY+LAogICAgLy8gICBsZW5ndGg6IFVpbnROPDE2PgogICAgLy8gKTogRHluYW1pY0FycmF5PFVpbnROPDE2Pj4gewogICAgcHJvdG8gNCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czoyNgogICAgLy8gY29uc3Qgc3RhdGUgPSBwY2cxNkluaXQoc2VlZC5ieXRlcyk7CiAgICBmcmFtZV9kaWcgLTQKICAgIGNhbGxzdWIgcGNnMTZJbml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czoyOQogICAgLy8gY29uc3QgW25ld1N0YXRlLCBzZXF1ZW5jZV0gPSBwY2cxNlJhbmRvbShzdGF0ZSwgbG93ZXJfYm91bmQubmF0aXZlLCB1cHBlcl9ib3VuZC5uYXRpdmUsIGxlbmd0aC5uYXRpdmUpOwogICAgZnJhbWVfZGlnIC0zCiAgICBidG9pCiAgICBmcmFtZV9kaWcgLTIKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAtMQogICAgYnRvaQogICAgY2FsbHN1YiBwY2cxNlJhbmRvbQogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czozMQogICAgLy8gcmV0dXJuIHNlcXVlbmNlOwogICAgcmV0c3ViCgoKLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjpwY2cxNkluaXQoc2VlZDogYnl0ZXMpIC0+IHVpbnQ2NDoKcGNnMTZJbml0OgogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjEwNQogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHBjZzE2SW5pdChzZWVkOiBieXRlcyk6IFBDRzMyU1RBVEUgewogICAgcHJvdG8gMSAxCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTA2CiAgICAvLyByZXR1cm4gcGNnMzJJbml0KHNlZWQpOwogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIHBjZzMySW5pdAogICAgcmV0c3ViCgoKLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjpwY2cxNlJhbmRvbShzdGF0ZTogdWludDY0LCBsb3dlckJvdW5kOiB1aW50NjQsIHVwcGVyQm91bmQ6IHVpbnQ2NCwgbGVuZ3RoOiB1aW50NjQpIC0+IHVpbnQ2NCwgYnl0ZXM6CnBjZzE2UmFuZG9tOgogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjEzMC0xMzUKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBwY2cxNlJhbmRvbSgKICAgIC8vICAgc3RhdGU6IFBDRzMyU1RBVEUsCiAgICAvLyAgIGxvd2VyQm91bmQ6IHVpbnQ2NCwKICAgIC8vICAgdXBwZXJCb3VuZDogdWludDY0LAogICAgLy8gICBsZW5ndGg6IHVpbnQ2NAogICAgLy8gKTogW1BDRzMyU1RBVEUsIER5bmFtaWNBcnJheTxVaW50TjwxNj4+XSB7CiAgICBwcm90byA0IDIKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxMzYKICAgIC8vIGNvbnN0IHJlc3VsdCA9IG5ldyBEeW5hbWljQXJyYXk8VWludE48MTY+PigpOwogICAgYnl0ZWNfMSAvLyAweDAwMDAKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxMzcKICAgIC8vIGNvbnN0IFtuZXdTdGF0ZSwgc2VxdWVuY2VdID0gX19wY2czMkJvdW5kZWRTZXF1ZW5jZShzdGF0ZSwgMTYsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIGxlbmd0aCk7CiAgICBmcmFtZV9kaWcgLTQKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIGZyYW1lX2RpZyAtMwogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgX19wY2czMkJvdW5kZWRTZXF1ZW5jZQogICAgc3dhcAogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjE0MAogICAgLy8gZm9yIChsZXQgaSA9IFVpbnQ2NCgwKTsgaSA8IGxlbmd0aDsgaSA9IGkgKyAxKSB7CiAgICBpbnRjXzEgLy8gMAoKcGNnMTZSYW5kb21fd2hpbGVfdG9wQDE6CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTQwCiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTEKICAgIDwKICAgIGJ6IHBjZzE2UmFuZG9tX2FmdGVyX3doaWxlQDQKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxNDEKICAgIC8vIHJlc3VsdC5wdXNoKG5ldyBVaW50TjwxNj4ob3AuZXh0cmFjdFVpbnQxNihzZXF1ZW5jZSwgMiArIGkgKiAyKSkpOwogICAgZnJhbWVfZGlnIDAKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjXzIgLy8gMgogICAgKgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGZyYW1lX2RpZyAxCiAgICBzd2FwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAyCiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxNDAKICAgIC8vIGZvciAobGV0IGkgPSBVaW50NjQoMCk7IGkgPCBsZW5ndGg7IGkgPSBpICsgMSkgewogICAgaW50Y18wIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMwogICAgYiBwY2cxNlJhbmRvbV93aGlsZV90b3BAMQoKcGNnMTZSYW5kb21fYWZ0ZXJfd2hpbGVANDoKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxNDQKICAgIC8vIHJldHVybiBbbmV3U3RhdGUsIHJlc3VsdC5jb3B5KCldOwogICAgZnJhbWVfZGlnIDIKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6OkxpYlBjZzMyRXhwb3NlclRzLmJvdW5kZWRfcmFuZF91aW50OChzZWVkOiBieXRlcywgbG93ZXJfYm91bmQ6IGJ5dGVzLCB1cHBlcl9ib3VuZDogYnl0ZXMsIGxlbmd0aDogYnl0ZXMpIC0+IGJ5dGVzOgpib3VuZGVkX3JhbmRfdWludDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czozNC0zOQogICAgLy8gYm91bmRlZF9yYW5kX3VpbnQ4KAogICAgLy8gICBzZWVkOiBTdGF0aWNBcnJheTxCeXRlLCA4PiwKICAgIC8vICAgbG93ZXJfYm91bmQ6IFVpbnROPDg+LAogICAgLy8gICB1cHBlcl9ib3VuZDogVWludE48OD4sCiAgICAvLyAgIGxlbmd0aDogVWludE48MTY+CiAgICAvLyApOiBEeW5hbWljQXJyYXk8VWludE48OD4+IHsKICAgIHByb3RvIDQgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6NDAKICAgIC8vIGNvbnN0IHN0YXRlID0gcGNnOEluaXQoc2VlZC5ieXRlcyk7CiAgICBmcmFtZV9kaWcgLTQKICAgIGNhbGxzdWIgcGNnOEluaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9saWJfcGNnMzJfZXhwb3Nlcl90cy9jb250cmFjdC5hbGdvLnRzOjQzCiAgICAvLyBjb25zdCBbbmV3U3RhdGUsIHNlcXVlbmNlXSA9IHBjZzhSYW5kb20oc3RhdGUsIGxvd2VyX2JvdW5kLm5hdGl2ZSwgdXBwZXJfYm91bmQubmF0aXZlLCBsZW5ndGgubmF0aXZlKTsKICAgIGZyYW1lX2RpZyAtMwogICAgYnRvaQogICAgZnJhbWVfZGlnIC0yCiAgICBidG9pCiAgICBmcmFtZV9kaWcgLTEKICAgIGJ0b2kKICAgIGNhbGxzdWIgcGNnOFJhbmRvbQogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czo0NQogICAgLy8gcmV0dXJuIHNlcXVlbmNlOwogICAgcmV0c3ViCgoKLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjpwY2c4SW5pdChzZWVkOiBieXRlcykgLT4gdWludDY0OgpwY2c4SW5pdDoKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxMDkKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBwY2c4SW5pdChzZWVkOiBieXRlcyk6IFBDRzMyU1RBVEUgewogICAgcHJvdG8gMSAxCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTEwCiAgICAvLyByZXR1cm4gcGNnMzJJbml0KHNlZWQpOwogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIHBjZzMySW5pdAogICAgcmV0c3ViCgoKLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjpwY2c4UmFuZG9tKHN0YXRlOiB1aW50NjQsIGxvd2VyQm91bmQ6IHVpbnQ2NCwgdXBwZXJCb3VuZDogdWludDY0LCBsZW5ndGg6IHVpbnQ2NCkgLT4gdWludDY0LCBieXRlczoKcGNnOFJhbmRvbToKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxNDctMTUyCiAgICAvLyBleHBvcnQgZnVuY3Rpb24gcGNnOFJhbmRvbSgKICAgIC8vICAgc3RhdGU6IFBDRzMyU1RBVEUsCiAgICAvLyAgIGxvd2VyQm91bmQ6IHVpbnQ2NCwKICAgIC8vICAgdXBwZXJCb3VuZDogdWludDY0LAogICAgLy8gICBsZW5ndGg6IHVpbnQ2NAogICAgLy8gKTogW1BDRzMyU1RBVEUsIER5bmFtaWNBcnJheTxVaW50Tjw4Pj5dIHsKICAgIHByb3RvIDQgMgogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjE1MwogICAgLy8gY29uc3QgcmVzdWx0ID0gbmV3IER5bmFtaWNBcnJheTxVaW50Tjw4Pj4oKTsKICAgIGJ5dGVjXzEgLy8gMHgwMDAwCiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTU0CiAgICAvLyBjb25zdCBbbmV3U3RhdGUsIHNlcXVlbmNlXSA9IF9fcGNnMzJCb3VuZGVkU2VxdWVuY2Uoc3RhdGUsIDgsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIGxlbmd0aCk7CiAgICBmcmFtZV9kaWcgLTQKICAgIGludGNfMyAvLyA4CiAgICBmcmFtZV9kaWcgLTMKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIF9fcGNnMzJCb3VuZGVkU2VxdWVuY2UKICAgIHN3YXAKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxNTcKICAgIC8vIGZvciAobGV0IGkgPSBVaW50NjQoMCk7IGkgPCBsZW5ndGg7IGkgPSBpICsgMSkgewogICAgaW50Y18xIC8vIDAKCnBjZzhSYW5kb21fd2hpbGVfdG9wQDE6CiAgICAvLyBsaWJfcGNnL3BjZzMyLmFsZ28udHM6MTU3CiAgICAvLyBmb3IgKGxldCBpID0gVWludDY0KDApOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHsKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTEKICAgIDwKICAgIGJ6IHBjZzhSYW5kb21fYWZ0ZXJfd2hpbGVANAogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjE1OAogICAgLy8gcmVzdWx0LnB1c2gobmV3IFVpbnROPDg+KG9wLmJ0b2kob3AuZXh0cmFjdChzZXF1ZW5jZSwgMiArIGksIDEpKSkpOwogICAgZnJhbWVfZGlnIDAKICAgIGV4dHJhY3QgMiAwCiAgICBpbnRjXzIgLy8gMgogICAgZnJhbWVfZGlnIDMKICAgIGR1cAogICAgY292ZXIgMwogICAgKwogICAgZnJhbWVfZGlnIDEKICAgIHN3YXAKICAgIGludGNfMCAvLyAxCiAgICBleHRyYWN0MwogICAgYnRvaQogICAgaXRvYgogICAgZXh0cmFjdCA3IDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gbGliX3BjZy9wY2czMi5hbGdvLnRzOjE1NwogICAgLy8gZm9yIChsZXQgaSA9IFVpbnQ2NCgwKTsgaSA8IGxlbmd0aDsgaSA9IGkgKyAxKSB7CiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAzCiAgICBiIHBjZzhSYW5kb21fd2hpbGVfdG9wQDEKCnBjZzhSYW5kb21fYWZ0ZXJfd2hpbGVANDoKICAgIC8vIGxpYl9wY2cvcGNnMzIuYWxnby50czoxNjEKICAgIC8vIHJldHVybiBbbmV3U3RhdGUsIHJlc3VsdC5jb3B5KCldOwogICAgZnJhbWVfZGlnIDIKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL2xpYl9wY2czMl9leHBvc2VyX3RzL2NvbnRyYWN0LmFsZ28udHM6OkxpYlBjZzMyRXhwb3NlclRzLnVwZGF0ZSgpIC0+IHZvaWQ6CnVwZGF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9saWJfcGNnMzJfZXhwb3Nlcl90cy9jb250cmFjdC5hbGdvLnRzOjQ5CiAgICAvLyB1cGRhdGUoKSB7CiAgICBwcm90byAwIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9saWJfcGNnMzJfZXhwb3Nlcl90cy9jb250cmFjdC5hbGdvLnRzOjUwCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gR2xvYmFsLmNyZWF0b3JBZGRyZXNzKTsKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydAogICAgcmV0c3ViCg==","clear":"I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMvbGliX3BjZzMyX2V4cG9zZXJfdHMvY29udHJhY3QuYWxnby50czo6TGliUGNnMzJFeHBvc2VyVHMuY2xlYXJTdGF0ZVByb2dyYW06CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


/**
 * The argument types for the LibPcg32ExposerTs contract
 */
export type LibPcg32ExposerTsArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]': {
      seed: Uint8Array
      lowerBound: bigint | number
      upperBound: bigint | number
      length: bigint | number
    }
    'bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]': {
      seed: Uint8Array
      lowerBound: bigint | number
      upperBound: bigint | number
      length: bigint | number
    }
    'bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]': {
      seed: Uint8Array
      lowerBound: bigint | number
      upperBound: bigint | number
      length: bigint | number
    }
    'update()void': Record<string, never>
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]': [seed: Uint8Array, lowerBound: bigint | number, upperBound: bigint | number, length: bigint | number]
    'bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]': [seed: Uint8Array, lowerBound: bigint | number, upperBound: bigint | number, length: bigint | number]
    'bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]': [seed: Uint8Array, lowerBound: bigint | number, upperBound: bigint | number, length: bigint | number]
    'update()void': []
  }
}

/**
 * The return type for each method
 */
export type LibPcg32ExposerTsReturns = {
  'bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]': number[]
  'bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]': number[]
  'bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]': number[]
  'update()void': void
}

/**
 * Defines the types of available calls and state of the LibPcg32ExposerTs smart contract.
 */
export type LibPcg32ExposerTsTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]' | 'bounded_rand_uint32', {
      argsObj: LibPcg32ExposerTsArgs['obj']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]']
      argsTuple: LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]']
      returns: LibPcg32ExposerTsReturns['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]']
    }>
    & Record<'bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]' | 'bounded_rand_uint16', {
      argsObj: LibPcg32ExposerTsArgs['obj']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]']
      argsTuple: LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]']
      returns: LibPcg32ExposerTsReturns['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]']
    }>
    & Record<'bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]' | 'bounded_rand_uint8', {
      argsObj: LibPcg32ExposerTsArgs['obj']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]']
      argsTuple: LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]']
      returns: LibPcg32ExposerTsReturns['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]']
    }>
    & Record<'update()void' | 'update', {
      argsObj: LibPcg32ExposerTsArgs['obj']['update()void']
      argsTuple: LibPcg32ExposerTsArgs['tuple']['update()void']
      returns: LibPcg32ExposerTsReturns['update()void']
    }>
}

/**
 * Defines the possible abi call signatures.
 */
export type LibPcg32ExposerTsSignatures = keyof LibPcg32ExposerTsTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type LibPcg32ExposerTsNonVoidMethodSignatures = keyof LibPcg32ExposerTsTypes['methods'] extends infer T ? T extends keyof LibPcg32ExposerTsTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the LibPcg32ExposerTs smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends LibPcg32ExposerTsSignatures> = LibPcg32ExposerTsTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the LibPcg32ExposerTs smart contract to the method's return type
 */
export type MethodReturn<TSignature extends LibPcg32ExposerTsSignatures> = LibPcg32ExposerTsTypes['methods'][TSignature]['returns']


/**
 * Defines supported create method params for this smart contract
 */
export type LibPcg32ExposerTsCreateCallParams =
  | Expand<AppClientBareCallParams & {method?: never} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines arguments required for the deploy method.
 */
export type LibPcg32ExposerTsDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: LibPcg32ExposerTsCreateCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the LibPcg32ExposerTs smart contract
 */
export abstract class LibPcg32ExposerTsParamsFactory {
  /**
   * Constructs a no op call for the bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static boundedRandUint32(params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.seed, params.args.lowerBound, params.args.upperBound, params.args.length],
    }
  }
  /**
   * Constructs a no op call for the bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static boundedRandUint16(params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.seed, params.args.lowerBound, params.args.upperBound, params.args.length],
    }
  }
  /**
   * Constructs a no op call for the bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static boundedRandUint8(params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.seed, params.args.lowerBound, params.args.upperBound, params.args.length],
    }
  }
  /**
   * Constructs a no op call for the update()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static update(params: CallParams<LibPcg32ExposerTsArgs['obj']['update()void'] | LibPcg32ExposerTsArgs['tuple']['update()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'update()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the LibPcg32ExposerTs smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class LibPcg32ExposerTsFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `LibPcg32ExposerTsFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClientInterface {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new LibPcg32ExposerTsClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new LibPcg32ExposerTsClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the LibPcg32ExposerTs smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: LibPcg32ExposerTsDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
    })
    return { result: result.result, appClient: new LibPcg32ExposerTsClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the LibPcg32ExposerTs smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.params.bare.create(params)
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the LibPcg32ExposerTs smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.createTransaction.bare.create(params)
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the LibPcg32ExposerTs smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        const result = await this.appFactory.send.bare.create(params)
        return { result: result.result, appClient: new LibPcg32ExposerTsClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the LibPcg32ExposerTs smart contract
 */
export class LibPcg32ExposerTsClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `LibPcg32ExposerTsClient`
   *
   * @param appClient An `AppClient` instance which has been created with the LibPcg32ExposerTs app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `LibPcg32ExposerTsClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends LibPcg32ExposerTsNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `LibPcg32ExposerTsClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<LibPcg32ExposerTsClient> {
    return new LibPcg32ExposerTsClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `LibPcg32ExposerTsClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<LibPcg32ExposerTsClient> {
    return new LibPcg32ExposerTsClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClientInterface {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Makes a clear_state call to an existing instance of the LibPcg32ExposerTs smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    boundedRandUint32: (params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(LibPcg32ExposerTsParamsFactory.boundedRandUint32(params))
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    boundedRandUint16: (params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(LibPcg32ExposerTsParamsFactory.boundedRandUint16(params))
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    boundedRandUint8: (params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(LibPcg32ExposerTsParamsFactory.boundedRandUint8(params))
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `update()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    update: (params: CallParams<LibPcg32ExposerTsArgs['obj']['update()void'] | LibPcg32ExposerTsArgs['tuple']['update()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(LibPcg32ExposerTsParamsFactory.update(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the LibPcg32ExposerTs smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    boundedRandUint32: (params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(LibPcg32ExposerTsParamsFactory.boundedRandUint32(params))
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    boundedRandUint16: (params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(LibPcg32ExposerTsParamsFactory.boundedRandUint16(params))
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    boundedRandUint8: (params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(LibPcg32ExposerTsParamsFactory.boundedRandUint8(params))
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `update()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    update: (params: CallParams<LibPcg32ExposerTsArgs['obj']['update()void'] | LibPcg32ExposerTsArgs['tuple']['update()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(LibPcg32ExposerTsParamsFactory.update(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Makes a clear_state call to an existing instance of the LibPcg32ExposerTs smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    boundedRandUint32: async (params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(LibPcg32ExposerTsParamsFactory.boundedRandUint32(params))
      return {...result, return: result.return as unknown as (undefined | LibPcg32ExposerTsReturns['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]'])}
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    boundedRandUint16: async (params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(LibPcg32ExposerTsParamsFactory.boundedRandUint16(params))
      return {...result, return: result.return as unknown as (undefined | LibPcg32ExposerTsReturns['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]'])}
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    boundedRandUint8: async (params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(LibPcg32ExposerTsParamsFactory.boundedRandUint8(params))
      return {...result, return: result.return as unknown as (undefined | LibPcg32ExposerTsReturns['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]'])}
    },

    /**
     * Makes a call to the LibPcg32ExposerTs smart contract using the `update()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    update: async (params: CallParams<LibPcg32ExposerTsArgs['obj']['update()void'] | LibPcg32ExposerTsArgs['tuple']['update()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(LibPcg32ExposerTsParamsFactory.update(params))
      return {...result, return: result.return as unknown as (undefined | LibPcg32ExposerTsReturns['update()void'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new LibPcg32ExposerTsClient(this.appClient.clone(params))
  }

  /**
   * Methods to access state for the current LibPcg32ExposerTs app
   */
  state = {
  }

  public newGroup(): LibPcg32ExposerTsComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[] method call against the LibPcg32ExposerTs contract
       */
      boundedRandUint32(params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.boundedRandUint32(params)))
        resultMappers.push((v) => client.decodeReturnValue('bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]', v))
        return this
      },
      /**
       * Add a bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[] method call against the LibPcg32ExposerTs contract
       */
      boundedRandUint16(params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.boundedRandUint16(params)))
        resultMappers.push((v) => client.decodeReturnValue('bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]', v))
        return this
      },
      /**
       * Add a bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[] method call against the LibPcg32ExposerTs contract
       */
      boundedRandUint8(params: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.boundedRandUint8(params)))
        resultMappers.push((v) => client.decodeReturnValue('bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]', v))
        return this
      },
      /**
       * Add a update()void method call against the LibPcg32ExposerTs contract
       */
      update(params: CallParams<LibPcg32ExposerTsArgs['obj']['update()void'] | LibPcg32ExposerTsArgs['tuple']['update()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.update(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a clear state call to the LibPcg32ExposerTs contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as LibPcg32ExposerTsComposer
  }
}
export type LibPcg32ExposerTsComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  boundedRandUint32(params?: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]']>): LibPcg32ExposerTsComposer<[...TReturns, LibPcg32ExposerTsReturns['bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]'] | undefined]>

  /**
   * Calls the bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  boundedRandUint16(params?: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]']>): LibPcg32ExposerTsComposer<[...TReturns, LibPcg32ExposerTsReturns['bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]'] | undefined]>

  /**
   * Calls the bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  boundedRandUint8(params?: CallParams<LibPcg32ExposerTsArgs['obj']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]'] | LibPcg32ExposerTsArgs['tuple']['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]']>): LibPcg32ExposerTsComposer<[...TReturns, LibPcg32ExposerTsReturns['bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]'] | undefined]>

  /**
   * Calls the update()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  update(params?: CallParams<LibPcg32ExposerTsArgs['obj']['update()void'] | LibPcg32ExposerTsArgs['tuple']['update()void']>): LibPcg32ExposerTsComposer<[...TReturns, LibPcg32ExposerTsReturns['update()void'] | undefined]>

  /**
   * Makes a clear_state call to an existing instance of the LibPcg32ExposerTs smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): LibPcg32ExposerTsComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): LibPcg32ExposerTsComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): TransactionComposer
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<LibPcg32ExposerTsComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<LibPcg32ExposerTsComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<LibPcg32ExposerTsComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<LibPcg32ExposerTsComposerResults<TReturns>>
}
export type LibPcg32ExposerTsComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

