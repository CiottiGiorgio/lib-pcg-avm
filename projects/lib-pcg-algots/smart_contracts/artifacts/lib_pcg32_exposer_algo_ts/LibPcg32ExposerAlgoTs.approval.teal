#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 8 0 2 6364136223846793005 1442695040888963407 4294967295
    bytecblock 0x000a 0x151f7c75
    txn NumAppArgs
    bz main_bare_routing@10
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xed06f70a 0x8d7cce79 0xd0a35e1e // method "bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]", method "bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]", method "bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]"
    txna ApplicationArgs 0
    match bounded_rand_uint32 bounded_rand_uint16 bounded_rand_uint8
    err

main_bare_routing@10:
    intc_2 // NoOp
    pushint 4 // UpdateApplication
    txn OnCompletion
    match main___algots__.defaultCreate@11 main_update@12
    err

main_update@12:
    txn ApplicationID
    assert // can only call when not creating
    txn Sender
    global CreatorAddress
    ==
    return

main___algots__.defaultCreate@11:
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// lib_pcg/pcg32.algo.ts::pcg32Init(seed: bytes) -> uint64:
pcg32Init:
    proto 1 1
    frame_dig -1
    len
    intc_1 // 8
    ==
    assert
    frame_dig -1
    btoi
    intc_2 // 0
    intc 4 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    addw
    bury 1
    intc 4 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    retsub


// lib_pcg/pcg32.algo.ts::__pcg32BoundedSequence(state: uint64, bitSize: uint64, lowerBound: uint64, upperBound: uint64, length: uint64) -> bytes:
__pcg32BoundedSequence:
    proto 5 1
    pushbytes ""
    dupn 7
    frame_dig -1
    pushint 65536 // 65536
    <
    assert
    frame_dig -1
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    frame_dig -4
    intc_1 // 8
    ==
    bnz __pcg32BoundedSequence_bool_true@3
    frame_dig -4
    pushint 16 // 16
    ==
    bnz __pcg32BoundedSequence_bool_true@3
    frame_dig -4
    pushint 32 // 32
    ==
    bz __pcg32BoundedSequence_bool_false@4

__pcg32BoundedSequence_bool_true@3:
    intc_0 // 1

__pcg32BoundedSequence_bool_merge@5:
    assert
    frame_dig -4
    pushint 3 // 3
    shr
    dup
    frame_bury 1
    intc_1 // 8
    swap
    -
    frame_bury 7
    frame_dig -3
    bnz __pcg32BoundedSequence_else_body@11
    frame_dig -2
    bnz __pcg32BoundedSequence_else_body@11
    intc_2 // 0
    frame_bury 4
    frame_dig -5
    frame_bury 3

__pcg32BoundedSequence_while_top@8:
    frame_dig 4
    frame_dig -1
    <
    bz __pcg32BoundedSequence_after_if_else@24
    frame_dig 3
    callsub __pcg32UnboundedRandom
    dup
    intc_2 // 0
    extract_uint64
    frame_bury 3
    extract 8 8
    frame_dig 7
    frame_dig 1
    extract3
    frame_dig 8
    swap
    concat
    frame_bury 8
    frame_dig 4
    intc_0 // 1
    +
    frame_bury 4
    b __pcg32BoundedSequence_while_top@8

__pcg32BoundedSequence_after_if_else@24:
    frame_dig -5
    itob
    frame_dig 8
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec_0 // 0x000a
    concat
    swap
    concat
    frame_bury 0
    retsub

__pcg32BoundedSequence_else_body@11:
    frame_dig -2
    bz __pcg32BoundedSequence_else_body@13
    frame_dig -2
    intc_0 // 1
    >
    assert
    intc_0 // 1
    frame_dig -4
    shl
    frame_dig -2
    >
    assert
    frame_dig -2
    intc_0 // 1
    -
    frame_dig -3
    >
    assert
    frame_dig -2
    frame_dig -3
    -
    frame_bury 0

__pcg32BoundedSequence_after_if_else@14:
    frame_dig 0
    dup
    ~
    intc_0 // 1
    addw
    bury 1
    intc 6 // 4294967295
    &
    swap
    %
    frame_bury 6
    intc_2 // 0
    frame_bury 5
    frame_dig -5
    frame_bury 3

__pcg32BoundedSequence_while_top@15:
    frame_dig 5
    frame_dig -1
    <
    bz __pcg32BoundedSequence_after_if_else@24

__pcg32BoundedSequence_while_top@17:
    frame_dig 3
    callsub __pcg32UnboundedRandom
    dup
    intc_2 // 0
    extract_uint64
    frame_bury 3
    intc_1 // 8
    extract_uint64
    dup
    frame_bury 2
    frame_dig 6
    >=
    bz __pcg32BoundedSequence_while_top@17
    frame_dig 2
    frame_dig 0
    %
    frame_dig -3
    +
    itob
    frame_dig 7
    frame_dig 1
    extract3
    frame_dig 8
    swap
    concat
    frame_bury 8
    frame_dig 5
    intc_0 // 1
    +
    frame_bury 5
    b __pcg32BoundedSequence_while_top@15

__pcg32BoundedSequence_else_body@13:
    intc_0 // 1
    frame_dig -4
    shl
    dup
    intc_0 // 1
    -
    frame_dig -3
    >
    assert
    frame_dig -3
    -
    frame_bury 0
    b __pcg32BoundedSequence_after_if_else@14

__pcg32BoundedSequence_bool_false@4:
    intc_2 // 0
    b __pcg32BoundedSequence_bool_merge@5


// lib_pcg/pcg32.algo.ts::__pcg32UnboundedRandom(state: uint64) -> bytes:
__pcg32UnboundedRandom:
    proto 1 1
    frame_dig -1
    intc 4 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    frame_dig -1
    pushint 18 // 18
    shr
    frame_dig -1
    ^
    pushint 27 // 27
    shr
    intc 6 // 4294967295
    &
    frame_dig -1
    pushint 59 // 59
    shr
    dup2
    shr
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    pushint 31 // 31
    &
    uncover 2
    swap
    shl
    intc 6 // 4294967295
    &
    |
    swap
    itob
    swap
    itob
    concat
    retsub


// smart_contracts/lib_pcg32_exposer_algo_ts/contract.algo.ts::LibPcg32ExposerAlgoTs.bounded_rand_uint32[routing]() -> void:
bounded_rand_uint32:
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 8>
    txna ApplicationArgs 2
    dup
    len
    pushint 4 // 4
    ==
    assert // invalid number of bytes for arc4.uint32
    txna ApplicationArgs 3
    dup
    len
    pushint 4 // 4
    ==
    assert // invalid number of bytes for arc4.uint32
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    callsub pcg32Init
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    pushint 32 // 32
    cover 4
    cover 4
    callsub __pcg32BoundedSequence
    dup
    extract 0 8
    dig 1
    intc_1 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    bytec_0 // 0x000a
    concat
    swap
    concat
    dup
    intc_1 // 8
    extract_uint16
    dig 1
    len
    substring3
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts/lib_pcg32_exposer_algo_ts/contract.algo.ts::LibPcg32ExposerAlgoTs.bounded_rand_uint16[routing]() -> void:
bounded_rand_uint16:
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 8>
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    callsub pcg32Init
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    pushint 16 // 16
    cover 4
    cover 4
    callsub __pcg32BoundedSequence
    dup
    extract 0 8
    dig 1
    intc_1 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    bytec_0 // 0x000a
    concat
    swap
    concat
    dup
    intc_1 // 8
    extract_uint16
    dig 1
    len
    substring3
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts/lib_pcg32_exposer_algo_ts/contract.algo.ts::LibPcg32ExposerAlgoTs.bounded_rand_uint8[routing]() -> void:
bounded_rand_uint8:
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 8>
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 3
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    callsub pcg32Init
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    intc_1 // 8
    cover 4
    cover 4
    callsub __pcg32BoundedSequence
    dup
    extract 0 8
    dig 1
    intc_1 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    bytec_0 // 0x000a
    concat
    swap
    concat
    dup
    intc_1 // 8
    extract_uint16
    dig 1
    len
    substring3
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
