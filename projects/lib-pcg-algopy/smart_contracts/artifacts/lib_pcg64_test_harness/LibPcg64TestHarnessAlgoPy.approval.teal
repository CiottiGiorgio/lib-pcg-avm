#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 8 6364136223846793005 4294967295 1442695040888963407 1442695040888963409
    bytecblock 0x151f7c75
    txn NumAppArgs
    bz main___algopy_default_create@9
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xf4a8edd5 0x5f8ae181 // method "get_pcg64_sequence_native_uint64_return(byte[16],uint64,uint64,uint16)uint64[]", method "get_pcg64_sequence_arc4_uint64_return(byte[16],uint64,uint64,uint16)uint64[]"
    txna ApplicationArgs 0
    match get_pcg64_sequence_native_uint64_return get_pcg64_sequence_arc4_uint64_return
    err

main___algopy_default_create@9:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_0 // 1
    return


// lib_pcg.pcg32.__pcg32_init(initial_state: uint64, incr: uint64) -> uint64:
__pcg32_init:
    proto 2 1
    intc_1 // 0
    intc_3 // 6364136223846793005
    mulw
    bury 1
    frame_dig -1
    addw
    bury 1
    frame_dig -2
    addw
    bury 1
    intc_3 // 6364136223846793005
    mulw
    bury 1
    frame_dig -1
    addw
    bury 1
    retsub


// lib_pcg.pcg32.__pcg32_output(state: uint64) -> uint64:
__pcg32_output:
    proto 1 1
    frame_dig -1
    pushint 18 // 18
    shr
    frame_dig -1
    ^
    pushint 27 // 27
    shr
    intc 4 // 4294967295
    &
    frame_dig -1
    pushint 59 // 59
    shr
    dup2
    shr
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    pushint 31 // 31
    &
    uncover 2
    swap
    shl
    intc 4 // 4294967295
    &
    |
    retsub


// lib_pcg.pcg64.pcg64_init(seed: bytes) -> uint64, uint64:
pcg64_init:
    proto 1 2
    frame_dig -1
    len
    pushint 16 // 16
    ==
    assert
    frame_dig -1
    intc_1 // 0
    extract_uint64
    intc 5 // 1442695040888963407
    callsub __pcg32_init
    frame_dig -1
    intc_2 // 8
    extract_uint64
    intc 6 // 1442695040888963409
    callsub __pcg32_init
    retsub


// lib_pcg.pcg64.pcg64_random(state.0: uint64, state.1: uint64, lower_bound: uint64, upper_bound: uint64, length: uint64) -> uint64, uint64, bytes:
pcg64_random:
    proto 5 3
    pushbytes ""
    dupn 3
    pushbytes 0x0000
    frame_dig -3
    bnz pcg64_random_else_body@7
    frame_dig -2
    bnz pcg64_random_else_body@7
    intc_1 // 0
    frame_bury 2

pcg64_random_for_header@3:
    frame_dig 2
    frame_dig -1
    <
    bz pcg64_random_after_if_else@20
    frame_dig -5
    frame_dig -4
    callsub __pcg64_unbounded_random
    cover 2
    frame_bury -4
    frame_bury -5
    itob
    frame_dig 4
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 4
    frame_dig 2
    intc_0 // 1
    +
    frame_bury 2
    b pcg64_random_for_header@3

pcg64_random_after_if_else@20:
    frame_dig -5
    frame_dig -4
    frame_dig 4
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

pcg64_random_else_body@7:
    frame_dig -2
    bz pcg64_random_else_body@9
    frame_dig -2
    intc_0 // 1
    >
    assert
    frame_dig -2
    intc_0 // 1
    -
    frame_dig -3
    >
    assert
    frame_dig -2
    frame_dig -3
    -
    frame_bury 0

pcg64_random_after_if_else@10:
    frame_dig 0
    dup
    ~
    intc_0 // 1
    addw
    bury 1
    swap
    %
    frame_bury 3
    intc_1 // 0
    frame_bury 2

pcg64_random_for_header@11:
    frame_dig 2
    frame_dig -1
    <
    bz pcg64_random_after_if_else@20

pcg64_random_while_top@13:
    frame_dig -5
    frame_dig -4
    callsub __pcg64_unbounded_random
    dup
    cover 3
    frame_bury 1
    frame_bury -4
    frame_bury -5
    frame_dig 3
    >=
    bz pcg64_random_while_top@13
    frame_dig 1
    frame_dig 0
    %
    frame_dig -3
    +
    itob
    frame_dig 4
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 4
    frame_dig 2
    intc_0 // 1
    +
    frame_bury 2
    b pcg64_random_for_header@11

pcg64_random_else_body@9:
    frame_dig -3
    pushint 18446744073709551615 // 18446744073709551615
    <
    assert
    frame_dig -3
    itob
    pushbytes 0x010000000000000000
    swap
    b-
    btoi
    frame_bury 0
    b pcg64_random_after_if_else@10


// lib_pcg.pcg64.__pcg64_unbounded_random(state.0: uint64, state.1: uint64) -> uint64, uint64, uint64:
__pcg64_unbounded_random:
    proto 2 3
    frame_dig -2
    intc_3 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    dup
    !
    intc 6 // 1442695040888963409
    swap
    shl
    frame_dig -1
    intc_3 // 6364136223846793005
    mulw
    bury 1
    addw
    bury 1
    frame_dig -2
    callsub __pcg32_output
    pushint 32 // 32
    shl
    frame_dig -1
    callsub __pcg32_output
    |
    retsub


// smart_contracts.lib_pcg64_test_harness.contract.LibPcg64TestHarnessAlgoPy.get_pcg64_sequence_native_uint64_return[routing]() -> void:
get_pcg64_sequence_native_uint64_return:
    txna ApplicationArgs 1
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 16>
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    pushint 2 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    callsub pcg64_init
    uncover 4
    btoi
    uncover 4
    btoi
    uncover 4
    btoi
    callsub pcg64_random
    cover 2
    popn 2
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.lib_pcg64_test_harness.contract.LibPcg64TestHarnessAlgoPy.get_pcg64_sequence_arc4_uint64_return[routing]() -> void:
get_pcg64_sequence_arc4_uint64_return:
    txna ApplicationArgs 1
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 16>
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    pushint 2 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    callsub pcg64_init
    uncover 4
    btoi
    uncover 4
    btoi
    uncover 4
    btoi
    dup
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    cover 5
    callsub pcg64_random
    dup
    cover 3
    cover 3
    popn 2
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 0

get_pcg64_sequence_arc4_uint64_return_for_header@2:
    dup
    dig 2
    <
    bz get_pcg64_sequence_arc4_uint64_return_after_for@4
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    dig 5
    swap
    concat
    bury 5
    intc_0 // 1
    +
    bury 1
    b get_pcg64_sequence_arc4_uint64_return_for_header@2

get_pcg64_sequence_arc4_uint64_return_after_for@4:
    bytec_0 // 0x151f7c75
    dig 4
    concat
    log
    intc_0 // 1
    return
