#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 6364136223846793005 1 4294967295 32 1442695040888963407 1442695040888963409 1442695040888963411 1442695040888963413
    bytecblock 0x 0x01 0x0100000000000000000000000000000000
    txn NumAppArgs
    bz main___algopy_default_create@10
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0xda5d5f2c 0xce37f42f 0x6c0b4898 // method "get_pcg128_sequence_arc4_uint128_return(byte[32],uint128,uint128,uint16)uint128[]", method "runtime_asserts_pcg128_stack_array()void", method "runtime_failure_stack_byteslice_overflow()void"
    txna ApplicationArgs 0
    match get_pcg128_sequence_arc4_uint128_return runtime_asserts_pcg128_stack_array runtime_failure_stack_byteslice_overflow
    err

main___algopy_default_create@10:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// lib_pcg.pcg128.pcg128_init(seed: bytes) -> uint64, uint64, uint64, uint64:
pcg128_init:
    proto 1 4
    frame_dig -1
    len
    intc_3 // 32
    ==
    assert
    frame_dig -1
    pushint 0
    extract_uint64
    pushint 0
    intc_0 // 6364136223846793005
    mulw
    bury 1
    dup
    intc 4 // 1442695040888963407
    addw
    bury 1
    uncover 2
    addw
    bury 1
    intc_0 // 6364136223846793005
    mulw
    bury 1
    intc 4 // 1442695040888963407
    addw
    cover 2
    pop
    frame_dig -1
    pushint 8
    extract_uint64
    dig 1
    intc 5 // 1442695040888963409
    addw
    bury 1
    addw
    bury 1
    intc_0 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963409
    addw
    cover 2
    pop
    frame_dig -1
    pushint 16
    extract_uint64
    dig 1
    intc 6 // 1442695040888963411
    addw
    bury 1
    addw
    bury 1
    intc_0 // 6364136223846793005
    mulw
    bury 1
    intc 6 // 1442695040888963411
    addw
    cover 2
    pop
    frame_dig -1
    pushint 24
    extract_uint64
    swap
    intc 7 // 1442695040888963413
    addw
    bury 1
    addw
    bury 1
    intc_0 // 6364136223846793005
    mulw
    bury 1
    intc 7 // 1442695040888963413
    addw
    bury 1
    retsub


// lib_pcg.pcg128.pcg128_random(state.0: uint64, state.1: uint64, state.2: uint64, state.3: uint64, lower_bound: bytes, upper_bound: bytes, length: uint64) -> uint64, uint64, uint64, uint64, bytes:
pcg128_random:
    proto 7 5
    pushint 0
    dupn 2
    bytec_0 // ""
    frame_dig -1
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    frame_dig -3
    bytec_0 // 0x
    b==
    bz pcg128_random_else_body@7
    frame_dig -2
    bytec_0 // 0x
    b==
    bz pcg128_random_else_body@7
    pushint 0
    frame_bury 3

pcg128_random_for_header@3:
    frame_dig 3
    frame_dig -1
    <
    bz pcg128_random_after_if_else@20
    frame_dig -7
    frame_dig -6
    frame_dig -5
    frame_dig -4
    callsub __pcg128_unbounded_random
    cover 4
    frame_bury -4
    frame_bury -5
    frame_bury -6
    frame_bury -7
    frame_dig 4
    swap
    concat
    frame_bury 4
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b pcg128_random_for_header@3

pcg128_random_after_if_else@20:
    frame_dig -7
    frame_dig -6
    frame_dig -5
    frame_dig -4
    frame_dig 4
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    retsub

pcg128_random_else_body@7:
    frame_dig -2
    bytec_0 // 0x
    b!=
    bz pcg128_random_else_body@9
    frame_dig -2
    bytec_1 // 0x01
    b>
    assert
    frame_dig -2
    bytec_2 // 0x0100000000000000000000000000000000
    b<
    assert
    frame_dig -2
    bytec_1 // 0x01
    b-
    frame_dig -3
    b>
    assert
    frame_dig -2
    frame_dig -3
    b-
    frame_bury 0

pcg128_random_after_if_else@10:
    frame_dig 0
    dup
    b~
    bytec_1 // 0x01
    b+
    pushbytes 0xffffffffffffffffffffffffffffffff
    b&
    swap
    b%
    frame_bury 2
    pushint 0
    frame_bury 3

pcg128_random_for_header@11:
    frame_dig 3
    frame_dig -1
    <
    bz pcg128_random_after_if_else@20

pcg128_random_while_top@13:
    frame_dig -7
    frame_dig -6
    frame_dig -5
    frame_dig -4
    callsub __pcg128_unbounded_random
    dup
    cover 5
    frame_bury 1
    frame_bury -4
    frame_bury -5
    frame_bury -6
    frame_bury -7
    frame_dig 2
    b>=
    bz pcg128_random_while_top@13
    frame_dig 1
    frame_dig 0
    b%
    frame_dig -3
    b+
    pushint 16
    bzero
    b|
    frame_dig 4
    swap
    concat
    frame_bury 4
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b pcg128_random_for_header@11

pcg128_random_else_body@9:
    frame_dig -3
    pushbytes 0x80000000000000000000000000000000
    b<
    assert
    bytec_2 // 0x0100000000000000000000000000000000
    frame_dig -3
    b-
    frame_bury 0
    b pcg128_random_after_if_else@10


// lib_pcg.pcg128.__pcg128_unbounded_random(state.0: uint64, state.1: uint64, state.2: uint64, state.3: uint64) -> uint64, uint64, uint64, uint64, bytes:
__pcg128_unbounded_random:
    proto 4 5
    frame_dig -4
    intc_0 // 6364136223846793005
    mulw
    bury 1
    intc 4 // 1442695040888963407
    addw
    bury 1
    dup
    !
    intc 5 // 1442695040888963409
    swap
    shl
    frame_dig -3
    intc_0 // 6364136223846793005
    mulw
    bury 1
    addw
    bury 1
    dup
    !
    intc 6 // 1442695040888963411
    swap
    shl
    frame_dig -2
    intc_0 // 6364136223846793005
    mulw
    bury 1
    addw
    bury 1
    dup
    !
    intc 7 // 1442695040888963413
    swap
    shl
    frame_dig -1
    intc_0 // 6364136223846793005
    mulw
    bury 1
    addw
    bury 1
    frame_dig -4
    pushint 18
    shr
    frame_dig -4
    ^
    pushint 27
    shr
    intc_2 // 4294967295
    &
    frame_dig -4
    pushint 59
    shr
    dup2
    shr
    swap
    ~
    intc_1 // 1
    addw
    bury 1
    pushint 31
    &
    uncover 2
    swap
    shl
    intc_2 // 4294967295
    &
    |
    intc_3 // 32
    shl
    frame_dig -3
    pushint 18
    shr
    frame_dig -3
    ^
    pushint 27
    shr
    intc_2 // 4294967295
    &
    frame_dig -3
    pushint 59
    shr
    dup2
    shr
    swap
    ~
    intc_1 // 1
    addw
    bury 1
    pushint 31
    &
    uncover 2
    swap
    shl
    intc_2 // 4294967295
    &
    |
    |
    itob
    frame_dig -2
    pushint 18
    shr
    frame_dig -2
    ^
    pushint 27
    shr
    intc_2 // 4294967295
    &
    frame_dig -2
    pushint 59
    shr
    dup2
    shr
    swap
    ~
    intc_1 // 1
    addw
    bury 1
    pushint 31
    &
    uncover 2
    swap
    shl
    intc_2 // 4294967295
    &
    |
    intc_3 // 32
    shl
    frame_dig -1
    pushint 18
    shr
    frame_dig -1
    ^
    pushint 27
    shr
    intc_2 // 4294967295
    &
    frame_dig -1
    pushint 59
    shr
    dup2
    shr
    swap
    ~
    intc_1 // 1
    addw
    bury 1
    pushint 31
    &
    uncover 2
    swap
    shl
    intc_2 // 4294967295
    &
    |
    |
    itob
    concat
    retsub


// smart_contracts.lib_pcg128_test_harness.contract.LibPCG128TestHarnessAlgoPy.get_pcg128_sequence_arc4_uint128_return[routing]() -> void:
get_pcg128_sequence_arc4_uint128_return:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    pushint 16
    ==
    assert // invalid number of bytes for arc4.uint128
    txna ApplicationArgs 3
    dup
    len
    pushint 16
    ==
    assert // invalid number of bytes for arc4.uint128
    txna ApplicationArgs 4
    dup
    len
    pushint 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    callsub pcg128_init
    uncover 4
    btoi
    cover 4
    uncover 6
    uncover 6
    uncover 6
    callsub pcg128_random
    cover 4
    popn 4
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.lib_pcg128_test_harness.contract.LibPCG128TestHarnessAlgoPy.runtime_asserts_pcg128_stack_array[routing]() -> void:
runtime_asserts_pcg128_stack_array:
    intc_3 // 32
    bzero
    callsub pcg128_init
    bytec_0 // 0x
    dup
    pushint 255
    callsub pcg128_random
    popn 5
    intc_1 // 1
    return


// smart_contracts.lib_pcg128_test_harness.contract.LibPCG128TestHarnessAlgoPy.runtime_failure_stack_byteslice_overflow[routing]() -> void:
runtime_failure_stack_byteslice_overflow:
    intc_3 // 32
    bzero
    callsub pcg128_init
    bytec_0 // 0x
    dup
    pushint 256
    callsub pcg128_random
    popn 5
    intc_1 // 1
    return
