#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 8 0 4294967295 6364136223846793005 1442695040888963407
    bytecblock 0x151f7c75
    txn NumAppArgs
    bz main___algopy_default_create@14
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0x0c8478fb 0xae78e6e0 0x89d7f54a 0x13b952d7 0xd2071623 0xc22d18df 0x6c0b4898 // method "get_pcg32_sequence_arc4_uint32_return(byte[8],uint32,uint32,uint16)uint32[]", method "get_pcg32_sequence_arc4_uint16_return(byte[8],uint16,uint16,uint16)uint16[]", method "get_pcg32_sequence_arc4_uint8_return(byte[8],uint8,uint8,uint16)uint8[]", method "runtime_asserts_pcg32_stack_array()void", method "runtime_asserts_pcg16_stack_array()void", method "runtime_asserts_pcg8_stack_array()void", method "runtime_failure_stack_byteslice_overflow()void"
    txna ApplicationArgs 0
    match get_pcg32_sequence_arc4_uint32_return get_pcg32_sequence_arc4_uint16_return get_pcg32_sequence_arc4_uint8_return runtime_asserts_pcg32_stack_array runtime_asserts_pcg16_stack_array runtime_asserts_pcg8_stack_array runtime_failure_stack_byteslice_overflow
    err

main___algopy_default_create@14:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// lib_pcg.pcg32.pcg32_init(seed: bytes) -> uint64:
pcg32_init:
    proto 1 1
    frame_dig -1
    len
    intc_1 // 8
    ==
    assert
    frame_dig -1
    btoi
    intc_2 // 0
    intc 4 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    addw
    bury 1
    intc 4 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    retsub


// lib_pcg.pcg32.__pcg32_bounded_sequence(state: uint64, bit_size: uint64, lower_bound: uint64, upper_bound: uint64, length: uint64) -> uint64, bytes:
__pcg32_bounded_sequence:
    proto 5 2
    pushbytes ""
    dupn 5
    frame_dig -1
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    frame_dig -4
    intc_1 // 8
    ==
    bnz __pcg32_bounded_sequence_bool_true@3
    frame_dig -4
    pushint 16
    ==
    bnz __pcg32_bounded_sequence_bool_true@3
    frame_dig -4
    pushint 32
    ==
    bz __pcg32_bounded_sequence_bool_false@4

__pcg32_bounded_sequence_bool_true@3:
    intc_0 // 1

__pcg32_bounded_sequence_bool_merge@5:
    assert
    frame_dig -4
    pushint 3
    shr
    dup
    frame_bury 1
    intc_1 // 8
    swap
    -
    frame_bury 5
    frame_dig -3
    bnz __pcg32_bounded_sequence_else_body@12
    frame_dig -2
    bnz __pcg32_bounded_sequence_else_body@12
    intc_2 // 0
    frame_bury 3

__pcg32_bounded_sequence_for_header@8:
    frame_dig 3
    frame_dig -1
    <
    bz __pcg32_bounded_sequence_after_if_else@25
    frame_dig -5
    intc 4 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    frame_dig -5
    pushint 18
    shr
    frame_dig -5
    ^
    pushint 27
    shr
    intc_3 // 4294967295
    &
    frame_dig -5
    pushint 59
    shr
    dup2
    shr
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    pushint 31
    &
    uncover 2
    swap
    shl
    intc_3 // 4294967295
    &
    |
    itob
    frame_dig 5
    frame_dig 1
    extract3
    frame_dig 6
    swap
    concat
    frame_bury 6
    frame_dig 3
    intc_0 // 1
    +
    frame_bury 3
    frame_bury -5
    b __pcg32_bounded_sequence_for_header@8

__pcg32_bounded_sequence_after_if_else@25:
    frame_dig -5
    frame_dig 6
    frame_bury 1
    frame_bury 0
    retsub

__pcg32_bounded_sequence_else_body@12:
    frame_dig -2
    bz __pcg32_bounded_sequence_else_body@14
    frame_dig -2
    intc_0 // 1
    >
    assert
    intc_0 // 1
    frame_dig -4
    shl
    frame_dig -2
    >
    assert
    frame_dig -2
    intc_0 // 1
    -
    frame_dig -3
    >
    assert
    frame_dig -2
    frame_dig -3
    -
    frame_bury 0

__pcg32_bounded_sequence_after_if_else@15:
    frame_dig 0
    dup
    ~
    intc_0 // 1
    addw
    bury 1
    intc_3 // 4294967295
    &
    swap
    %
    frame_bury 4
    intc_2 // 0
    frame_bury 3

__pcg32_bounded_sequence_for_header@16:
    frame_dig 3
    frame_dig -1
    <
    bz __pcg32_bounded_sequence_after_if_else@25

__pcg32_bounded_sequence_while_top@18:
    frame_dig -5
    intc 4 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    frame_dig -5
    pushint 18
    shr
    frame_dig -5
    ^
    pushint 27
    shr
    intc_3 // 4294967295
    &
    frame_dig -5
    pushint 59
    shr
    dup2
    shr
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    pushint 31
    &
    uncover 2
    swap
    shl
    intc_3 // 4294967295
    &
    |
    dup
    frame_bury 2
    frame_dig 4
    >=
    bz __pcg32_bounded_sequence_after_if_else@21
    frame_dig 2
    frame_dig 0
    %
    frame_dig -3
    +
    itob
    frame_dig 5
    frame_dig 1
    extract3
    frame_dig 6
    swap
    concat
    frame_bury 6
    frame_dig 3
    intc_0 // 1
    +
    frame_bury 3
    frame_bury -5
    b __pcg32_bounded_sequence_for_header@16

__pcg32_bounded_sequence_after_if_else@21:
    frame_bury -5
    b __pcg32_bounded_sequence_while_top@18

__pcg32_bounded_sequence_else_body@14:
    intc_0 // 1
    frame_dig -4
    shl
    dup
    intc_0 // 1
    -
    frame_dig -3
    >
    assert
    frame_dig -3
    -
    frame_bury 0
    b __pcg32_bounded_sequence_after_if_else@15

__pcg32_bounded_sequence_bool_false@4:
    intc_2 // 0
    b __pcg32_bounded_sequence_bool_merge@5


// smart_contracts.lib_pcg32_test_harness.contract.LibPCG32TestHarnessAlgoPy.get_pcg32_sequence_arc4_uint32_return[routing]() -> void:
get_pcg32_sequence_arc4_uint32_return:
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 8>
    txna ApplicationArgs 2
    dup
    len
    pushint 4
    ==
    assert // invalid number of bytes for arc4.uint32
    txna ApplicationArgs 3
    dup
    len
    pushint 4
    ==
    assert // invalid number of bytes for arc4.uint32
    txna ApplicationArgs 4
    dup
    len
    pushint 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    callsub pcg32_init
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    pushint 32
    cover 4
    cover 4
    callsub __pcg32_bounded_sequence
    bury 1
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.lib_pcg32_test_harness.contract.LibPCG32TestHarnessAlgoPy.get_pcg32_sequence_arc4_uint16_return[routing]() -> void:
get_pcg32_sequence_arc4_uint16_return:
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 8>
    txna ApplicationArgs 2
    dup
    len
    pushint 2
    ==
    assert // invalid number of bytes for arc4.uint16
    txna ApplicationArgs 3
    dup
    len
    pushint 2
    ==
    assert // invalid number of bytes for arc4.uint16
    txna ApplicationArgs 4
    dup
    len
    pushint 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    callsub pcg32_init
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    pushint 16
    cover 4
    cover 4
    callsub __pcg32_bounded_sequence
    bury 1
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.lib_pcg32_test_harness.contract.LibPCG32TestHarnessAlgoPy.get_pcg32_sequence_arc4_uint8_return[routing]() -> void:
get_pcg32_sequence_arc4_uint8_return:
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 8>
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 3
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 4
    dup
    len
    pushint 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    callsub pcg32_init
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    btoi
    uncover 3
    intc_1 // 8
    cover 4
    cover 4
    callsub __pcg32_bounded_sequence
    bury 1
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.lib_pcg32_test_harness.contract.LibPCG32TestHarnessAlgoPy.runtime_asserts_pcg32_stack_array[routing]() -> void:
runtime_asserts_pcg32_stack_array:
    intc_1 // 8
    bzero
    callsub pcg32_init
    pushint 32
    intc_2 // 0
    dup
    pushint 1023
    callsub __pcg32_bounded_sequence
    popn 2
    intc_0 // 1
    return


// smart_contracts.lib_pcg32_test_harness.contract.LibPCG32TestHarnessAlgoPy.runtime_asserts_pcg16_stack_array[routing]() -> void:
runtime_asserts_pcg16_stack_array:
    intc_1 // 8
    bzero
    callsub pcg32_init
    pushint 16
    intc_2 // 0
    dup
    pushint 2047
    callsub __pcg32_bounded_sequence
    popn 2
    intc_0 // 1
    return


// smart_contracts.lib_pcg32_test_harness.contract.LibPCG32TestHarnessAlgoPy.runtime_asserts_pcg8_stack_array[routing]() -> void:
runtime_asserts_pcg8_stack_array:
    intc_1 // 8
    bzero
    callsub pcg32_init
    intc_1 // 8
    intc_2 // 0
    dup
    pushint 4094
    callsub __pcg32_bounded_sequence
    popn 2
    intc_0 // 1
    return


// smart_contracts.lib_pcg32_test_harness.contract.LibPCG32TestHarnessAlgoPy.runtime_failure_stack_byteslice_overflow[routing]() -> void:
runtime_failure_stack_byteslice_overflow:
    intc_1 // 8
    bzero
    callsub pcg32_init
    pushint 32
    intc_2 // 0
    dup
    pushint 1024
    callsub __pcg32_bounded_sequence
    popn 2
    intc_0 // 1
    return
