#pragma version 10

smart_contracts.lib_pcg32_exposer.contract.LibPcg32ExposerAlgopy.approval_program:
    // smart_contracts/lib_pcg32_exposer/contract.py:15
    // class LibPcg32ExposerAlgopy(arc4.ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@7
    method "bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint32[]"
    method "bounded_rand_uint16(byte[8],uint16,uint16,uint16)uint16[]"
    method "bounded_rand_uint8(byte[8],uint8,uint8,uint16)uint8[]"
    txna ApplicationArgs 0
    match main_bounded_rand_uint32_route@2 main_bounded_rand_uint16_route@3 main_bounded_rand_uint8_route@4
    err // reject transaction

main_bounded_rand_uint32_route@2:
    // smart_contracts/lib_pcg32_exposer/contract.py:16
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/lib_pcg32_exposer/contract.py:15
    // class LibPcg32ExposerAlgopy(arc4.ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/lib_pcg32_exposer/contract.py:16
    // @arc4.abimethod
    callsub bounded_rand_uint32
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_bounded_rand_uint16_route@3:
    // smart_contracts/lib_pcg32_exposer/contract.py:32
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/lib_pcg32_exposer/contract.py:15
    // class LibPcg32ExposerAlgopy(arc4.ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/lib_pcg32_exposer/contract.py:32
    // @arc4.abimethod
    callsub bounded_rand_uint16
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_bounded_rand_uint8_route@4:
    // smart_contracts/lib_pcg32_exposer/contract.py:48
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/lib_pcg32_exposer/contract.py:15
    // class LibPcg32ExposerAlgopy(arc4.ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/lib_pcg32_exposer/contract.py:48
    // @arc4.abimethod
    callsub bounded_rand_uint8
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_bare_routing@7:
    // smart_contracts/lib_pcg32_exposer/contract.py:15
    // class LibPcg32ExposerAlgopy(arc4.ARC4Contract):
    int 0
    int 4
    txn OnCompletion
    match main_create@8 main_update@9
    err // reject transaction

main_create@8:
    // smart_contracts/lib_pcg32_exposer/contract.py:15
    // class LibPcg32ExposerAlgopy(arc4.ARC4Contract):
    txn ApplicationID
    !
    assert // is creating
    int 1
    return

main_update@9:
    // smart_contracts/lib_pcg32_exposer/contract.py:64
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    txn ApplicationID
    assert // is not creating
    // smart_contracts/lib_pcg32_exposer/contract.py:64-65
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    // def update(self) -> None:
    callsub update
    int 1
    return


// smart_contracts.lib_pcg32_exposer.contract.LibPcg32ExposerAlgopy.bounded_rand_uint32(seed: bytes, lower_bound: bytes, upper_bound: bytes, length: bytes) -> bytes:
bounded_rand_uint32:
    // smart_contracts/lib_pcg32_exposer/contract.py:16-23
    // @arc4.abimethod
    // def bounded_rand_uint32(
    //     self,
    //     seed: arc4.StaticArray[arc4.Byte, Literal[8]],
    //     lower_bound: arc4.UInt32,
    //     upper_bound: arc4.UInt32,
    //     length: arc4.UInt16,
    // ) -> arc4.DynamicArray[arc4.UInt32]:
    proto 4 1
    // smart_contracts/lib_pcg32_exposer/contract.py:24
    // state = pcg32_init(seed.bytes)
    frame_dig -4
    callsub pcg32_init
    // smart_contracts/lib_pcg32_exposer/contract.py:27
    // state, lower_bound.native, upper_bound.native, length.native
    frame_dig -3
    btoi
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    // smart_contracts/lib_pcg32_exposer/contract.py:26-28
    // state, sequence = pcg32_random(
    //     state, lower_bound.native, upper_bound.native, length.native
    // )
    callsub pcg32_random
    bury 1
    // smart_contracts/lib_pcg32_exposer/contract.py:30
    // return sequence
    retsub


// lib_pcg.xsh_rr_64_32.pcg32_init(seed: bytes) -> uint64:
pcg32_init:
    // lib_pcg/xsh_rr_64_32.py:10-11
    // @subroutine
    // def pcg32_init(seed: Bytes) -> PCG32STATE:
    proto 1 1
    // lib_pcg/xsh_rr_64_32.py:21
    // assert seed.length == 8
    frame_dig -1
    len
    int 8
    ==
    assert
    // lib_pcg/xsh_rr_64_32.py:23
    // return __pcg32_init(op.btoi(seed), UInt64(PCG_FIRST_INCREMENT))
    frame_dig -1
    btoi
    int 1442695040888963407
    callsub __pcg32_init
    retsub


// lib_pcg.xsh_rr_64_32.__pcg32_init(initial_state: uint64, incr: uint64) -> uint64:
__pcg32_init:
    // lib_pcg/xsh_rr_64_32.py:208-209
    // @subroutine
    // def __pcg32_init(initial_state: PCG32STATE, incr: UInt64) -> PCG32STATE:
    proto 2 1
    // lib_pcg/xsh_rr_64_32.py:210
    // state = __pcg32_step(UInt64(0), incr)
    int 0
    frame_dig -1
    callsub __pcg32_step
    // lib_pcg/xsh_rr_64_32.py:211
    // _high_addw, state = op.addw(state, initial_state)
    frame_dig -2
    addw
    bury 1
    // lib_pcg/xsh_rr_64_32.py:213
    // return __pcg32_step(state, incr)
    frame_dig -1
    callsub __pcg32_step
    retsub


// lib_pcg.xsh_rr_64_32.__pcg32_step(state: uint64, incr: uint64) -> uint64:
__pcg32_step:
    // lib_pcg/xsh_rr_64_32.py:216-217
    // @subroutine
    // def __pcg32_step(state: PCG32STATE, incr: UInt64) -> PCG32STATE:
    proto 2 1
    // lib_pcg/xsh_rr_64_32.py:218
    // _high_mul, low_mul = op.mulw(state, PCG_MULTIPLIER)
    frame_dig -2
    int 6364136223846793005
    mulw
    bury 1
    // lib_pcg/xsh_rr_64_32.py:219
    // _high_add, low_add = op.addw(low_mul, incr)
    frame_dig -1
    addw
    bury 1
    // lib_pcg/xsh_rr_64_32.py:221
    // return low_add
    retsub


// lib_pcg.xsh_rr_64_32.pcg32_random(state: uint64, lower_bound: uint64, upper_bound: uint64, length: uint64) -> uint64, bytes:
pcg32_random:
    // lib_pcg/xsh_rr_64_32.py:46-52
    // @subroutine
    // def pcg32_random(
    //     state: PCG32STATE,
    //     lower_bound: UInt64,
    //     upper_bound: UInt64,
    //     length: UInt64,
    // ) -> tuple[PCG32STATE, arc4.DynamicArray[arc4.UInt32]]:
    proto 4 2
    byte ""
    dupn 3
    // lib_pcg/xsh_rr_64_32.py:69
    // result = arc4.DynamicArray[arc4.UInt32]()
    byte 0x0000
    // lib_pcg/xsh_rr_64_32.py:71
    // if lower_bound == 0 and upper_bound == 0:
    frame_dig -3
    bnz pcg32_random_else_body@7
    frame_dig -2
    bnz pcg32_random_else_body@7
    // lib_pcg/xsh_rr_64_32.py:72
    // for i in urange(length):  # noqa: B007
    int 0
    frame_bury 2

pcg32_random_for_header@3:
    // lib_pcg/xsh_rr_64_32.py:72
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    frame_dig -1
    <
    bz pcg32_random_after_if_else@20
    // lib_pcg/xsh_rr_64_32.py:73
    // state, n = __pcg32_random(state)
    frame_dig -4
    callsub __pcg32_random
    swap
    frame_bury -4
    // lib_pcg/xsh_rr_64_32.py:75
    // result.append(arc4.UInt32(n))
    frame_dig 4
    extract 2 0
    swap
    itob
    extract 4 4
    concat
    dup
    len
    int 4
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 4
    // lib_pcg/xsh_rr_64_32.py:72
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    int 1
    +
    frame_bury 2
    b pcg32_random_for_header@3

pcg32_random_else_body@7:
    // lib_pcg/xsh_rr_64_32.py:77
    // if upper_bound != 0:
    frame_dig -2
    bz pcg32_random_else_body@9
    // lib_pcg/xsh_rr_64_32.py:78
    // assert upper_bound > 1
    frame_dig -2
    int 1
    >
    assert
    // lib_pcg/xsh_rr_64_32.py:79
    // assert upper_bound < (1 << 32)
    frame_dig -2
    int 4294967296
    <
    assert
    // lib_pcg/xsh_rr_64_32.py:80
    // assert lower_bound < (upper_bound - 1)
    frame_dig -2
    int 1
    -
    frame_dig -3
    >
    assert
    // lib_pcg/xsh_rr_64_32.py:82
    // absolute_bound = upper_bound - lower_bound
    frame_dig -2
    frame_dig -3
    -
    frame_bury 0
    b pcg32_random_after_if_else@10

pcg32_random_else_body@9:
    // lib_pcg/xsh_rr_64_32.py:84
    // assert lower_bound < ((1 << 32) - 1)
    frame_dig -3
    int 4294967295
    <
    assert
    // lib_pcg/xsh_rr_64_32.py:86
    // absolute_bound = (1 << 32) - lower_bound
    int 4294967296
    frame_dig -3
    -
    frame_bury 0

pcg32_random_after_if_else@10:
    // lib_pcg/xsh_rr_64_32.py:88
    // threshold = __mask_to_uint32(__uint64_twos(absolute_bound)) % absolute_bound
    frame_dig 0
    dup
    callsub __uint64_twos
    callsub __mask_to_uint32
    swap
    %
    frame_bury 3
    // lib_pcg/xsh_rr_64_32.py:90
    // for i in urange(length):  # noqa: B007
    int 0
    frame_bury 2

pcg32_random_for_header@11:
    // lib_pcg/xsh_rr_64_32.py:90
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    frame_dig -1
    <
    bz pcg32_random_after_for@19

pcg32_random_while_top@13:
    // lib_pcg/xsh_rr_64_32.py:92
    // state, candidate = __pcg32_random(state)
    frame_dig -4
    callsub __pcg32_random
    dup
    cover 2
    frame_bury 1
    frame_bury -4
    // lib_pcg/xsh_rr_64_32.py:93
    // if candidate >= threshold:
    frame_dig 3
    >=
    bz pcg32_random_while_top@13
    // lib_pcg/xsh_rr_64_32.py:95
    // result.append(arc4.UInt32((candidate % absolute_bound) + lower_bound))
    frame_dig 4
    extract 2 0
    frame_dig 1
    frame_dig 0
    %
    frame_dig -3
    +
    itob
    extract 4 4
    concat
    dup
    len
    int 4
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 4
    // lib_pcg/xsh_rr_64_32.py:90
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    int 1
    +
    frame_bury 2
    b pcg32_random_for_header@11

pcg32_random_after_for@19:

pcg32_random_after_if_else@20:
    // lib_pcg/xsh_rr_64_32.py:97
    // return state, result.copy()
    frame_dig -4
    frame_dig 4
    frame_bury 1
    frame_bury 0
    retsub


// lib_pcg.xsh_rr_64_32.__pcg32_random(state: uint64) -> uint64, uint64:
__pcg32_random:
    // lib_pcg/xsh_rr_64_32.py:224-225
    // @subroutine
    // def __pcg32_random(state: PCG32STATE) -> tuple[PCG32STATE, UInt64]:
    proto 1 2
    // lib_pcg/xsh_rr_64_32.py:226
    // return __pcg32_step(state, UInt64(PCG_FIRST_INCREMENT)), __pcg32_output(state)
    frame_dig -1
    int 1442695040888963407
    callsub __pcg32_step
    frame_dig -1
    callsub __pcg32_output
    retsub


// lib_pcg.xsh_rr_64_32.__pcg32_output(state: uint64) -> uint64:
__pcg32_output:
    // lib_pcg/xsh_rr_64_32.py:229-230
    // @subroutine
    // def __pcg32_output(state: PCG32STATE) -> UInt64:
    proto 1 1
    // lib_pcg/xsh_rr_64_32.py:232
    // __mask_to_uint32(((state >> 18) ^ state) >> 27), state >> 59
    frame_dig -1
    int 18
    shr
    frame_dig -1
    ^
    int 27
    shr
    callsub __mask_to_uint32
    frame_dig -1
    int 59
    shr
    // lib_pcg/xsh_rr_64_32.py:231-233
    // return __pcg32_rotation(
    //     __mask_to_uint32(((state >> 18) ^ state) >> 27), state >> 59
    // )
    callsub __pcg32_rotation
    retsub


// lib_pcg.xsh_rr_64_32.__mask_to_uint32(value: uint64) -> uint64:
__mask_to_uint32:
    // lib_pcg/xsh_rr_64_32.py:248-249
    // @subroutine
    // def __mask_to_uint32(value: UInt64) -> UInt64:
    proto 1 1
    // lib_pcg/xsh_rr_64_32.py:250
    // return value & ((1 << 32) - 1)
    frame_dig -1
    int 4294967295
    &
    retsub


// lib_pcg.xsh_rr_64_32.__pcg32_rotation(value: uint64, rot: uint64) -> uint64:
__pcg32_rotation:
    // lib_pcg/xsh_rr_64_32.py:236-237
    // @subroutine
    // def __pcg32_rotation(value: UInt64, rot: UInt64) -> UInt64:
    proto 2 1
    // lib_pcg/xsh_rr_64_32.py:238
    // return (value >> rot) | __mask_to_uint32(value << (__uint64_twos(rot) & 31))
    frame_dig -2
    frame_dig -1
    shr
    frame_dig -1
    callsub __uint64_twos
    int 31
    &
    frame_dig -2
    swap
    shl
    callsub __mask_to_uint32
    |
    retsub


// lib_pcg.xsh_rr_64_32.__uint64_twos(value: uint64) -> uint64:
__uint64_twos:
    // lib_pcg/xsh_rr_64_32.py:241-242
    // @subroutine
    // def __uint64_twos(value: UInt64) -> UInt64:
    proto 1 1
    // lib_pcg/xsh_rr_64_32.py:243
    // _addw_high, addw_low = op.addw(~value, 1)
    frame_dig -1
    ~
    int 1
    addw
    bury 1
    // lib_pcg/xsh_rr_64_32.py:245
    // return addw_low
    retsub


// smart_contracts.lib_pcg32_exposer.contract.LibPcg32ExposerAlgopy.bounded_rand_uint16(seed: bytes, lower_bound: bytes, upper_bound: bytes, length: bytes) -> bytes:
bounded_rand_uint16:
    // smart_contracts/lib_pcg32_exposer/contract.py:32-39
    // @arc4.abimethod
    // def bounded_rand_uint16(
    //     self,
    //     seed: arc4.StaticArray[arc4.Byte, Literal[8]],
    //     lower_bound: arc4.UInt16,
    //     upper_bound: arc4.UInt16,
    //     length: arc4.UInt16,
    // ) -> arc4.DynamicArray[arc4.UInt16]:
    proto 4 1
    // smart_contracts/lib_pcg32_exposer/contract.py:40
    // state = pcg16_init(seed.bytes)
    frame_dig -4
    callsub pcg16_init
    // smart_contracts/lib_pcg32_exposer/contract.py:43
    // state, lower_bound.native, upper_bound.native, length.native
    frame_dig -3
    btoi
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    // smart_contracts/lib_pcg32_exposer/contract.py:42-44
    // state, sequence = pcg16_random(
    //     state, lower_bound.native, upper_bound.native, length.native
    // )
    callsub pcg16_random
    bury 1
    // smart_contracts/lib_pcg32_exposer/contract.py:46
    // return sequence
    retsub


// lib_pcg.xsh_rr_64_32.pcg16_init(seed: bytes) -> uint64:
pcg16_init:
    // lib_pcg/xsh_rr_64_32.py:26-27
    // @subroutine
    // def pcg16_init(seed: Bytes) -> PCG32STATE:
    proto 1 1
    // lib_pcg/xsh_rr_64_32.py:33
    // return pcg32_init(seed)
    frame_dig -1
    callsub pcg32_init
    retsub


// lib_pcg.xsh_rr_64_32.pcg16_random(state: uint64, lower_bound: uint64, upper_bound: uint64, length: uint64) -> uint64, bytes:
pcg16_random:
    // lib_pcg/xsh_rr_64_32.py:100-106
    // @subroutine
    // def pcg16_random(
    //     state: PCG32STATE,
    //     lower_bound: UInt64,
    //     upper_bound: UInt64,
    //     length: UInt64,
    // ) -> tuple[PCG32STATE, arc4.DynamicArray[arc4.UInt16]]:
    proto 4 2
    byte ""
    dupn 3
    // lib_pcg/xsh_rr_64_32.py:123
    // result = arc4.DynamicArray[arc4.UInt16]()
    byte 0x0000
    // lib_pcg/xsh_rr_64_32.py:125
    // if lower_bound == 0 and upper_bound == 0:
    frame_dig -3
    bnz pcg16_random_else_body@7
    frame_dig -2
    bnz pcg16_random_else_body@7
    // lib_pcg/xsh_rr_64_32.py:126
    // for i in urange(length):  # noqa: B007
    int 0
    frame_bury 2

pcg16_random_for_header@3:
    // lib_pcg/xsh_rr_64_32.py:126
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    frame_dig -1
    <
    bz pcg16_random_after_if_else@20
    // lib_pcg/xsh_rr_64_32.py:127
    // state, n = __pcg32_random(state)
    frame_dig -4
    callsub __pcg32_random
    swap
    frame_bury -4
    // lib_pcg/xsh_rr_64_32.py:129
    // result.append(arc4.UInt16(n))
    frame_dig 4
    extract 2 0
    swap
    itob
    extract 6 2
    concat
    dup
    len
    int 2
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 4
    // lib_pcg/xsh_rr_64_32.py:126
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    int 1
    +
    frame_bury 2
    b pcg16_random_for_header@3

pcg16_random_else_body@7:
    // lib_pcg/xsh_rr_64_32.py:131
    // if upper_bound != 0:
    frame_dig -2
    bz pcg16_random_else_body@9
    // lib_pcg/xsh_rr_64_32.py:132
    // assert upper_bound > 1
    frame_dig -2
    int 1
    >
    assert
    // lib_pcg/xsh_rr_64_32.py:133
    // assert upper_bound < (1 << 16)
    frame_dig -2
    int 65536
    <
    assert
    // lib_pcg/xsh_rr_64_32.py:134
    // assert lower_bound < (upper_bound - 1)
    frame_dig -2
    int 1
    -
    frame_dig -3
    >
    assert
    // lib_pcg/xsh_rr_64_32.py:136
    // absolute_bound = upper_bound - lower_bound
    frame_dig -2
    frame_dig -3
    -
    frame_bury 0
    b pcg16_random_after_if_else@10

pcg16_random_else_body@9:
    // lib_pcg/xsh_rr_64_32.py:138
    // assert lower_bound < ((1 << 16) - 1)
    frame_dig -3
    int 65535
    <
    assert
    // lib_pcg/xsh_rr_64_32.py:140
    // absolute_bound = (1 << 16) - lower_bound
    int 65536
    frame_dig -3
    -
    frame_bury 0

pcg16_random_after_if_else@10:
    // lib_pcg/xsh_rr_64_32.py:142
    // threshold = __mask_to_uint32(__uint64_twos(absolute_bound)) % absolute_bound
    frame_dig 0
    dup
    callsub __uint64_twos
    callsub __mask_to_uint32
    swap
    %
    frame_bury 3
    // lib_pcg/xsh_rr_64_32.py:144
    // for i in urange(length):  # noqa: B007
    int 0
    frame_bury 2

pcg16_random_for_header@11:
    // lib_pcg/xsh_rr_64_32.py:144
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    frame_dig -1
    <
    bz pcg16_random_after_for@19

pcg16_random_while_top@13:
    // lib_pcg/xsh_rr_64_32.py:146
    // state, candidate = __pcg32_random(state)
    frame_dig -4
    callsub __pcg32_random
    dup
    cover 2
    frame_bury 1
    frame_bury -4
    // lib_pcg/xsh_rr_64_32.py:147
    // if candidate >= threshold:
    frame_dig 3
    >=
    bz pcg16_random_while_top@13
    // lib_pcg/xsh_rr_64_32.py:149
    // result.append(arc4.UInt16((candidate % absolute_bound) + lower_bound))
    frame_dig 4
    extract 2 0
    frame_dig 1
    frame_dig 0
    %
    frame_dig -3
    +
    itob
    extract 6 2
    concat
    dup
    len
    int 2
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 4
    // lib_pcg/xsh_rr_64_32.py:144
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    int 1
    +
    frame_bury 2
    b pcg16_random_for_header@11

pcg16_random_after_for@19:

pcg16_random_after_if_else@20:
    // lib_pcg/xsh_rr_64_32.py:151
    // return state, result.copy()
    frame_dig -4
    frame_dig 4
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts.lib_pcg32_exposer.contract.LibPcg32ExposerAlgopy.bounded_rand_uint8(seed: bytes, lower_bound: bytes, upper_bound: bytes, length: bytes) -> bytes:
bounded_rand_uint8:
    // smart_contracts/lib_pcg32_exposer/contract.py:48-55
    // @arc4.abimethod
    // def bounded_rand_uint8(
    //     self,
    //     seed: arc4.StaticArray[arc4.Byte, Literal[8]],
    //     lower_bound: arc4.UInt8,
    //     upper_bound: arc4.UInt8,
    //     length: arc4.UInt16,
    // ) -> arc4.DynamicArray[arc4.UInt8]:
    proto 4 1
    // smart_contracts/lib_pcg32_exposer/contract.py:56
    // state = pcg8_init(seed.bytes)
    frame_dig -4
    callsub pcg8_init
    // smart_contracts/lib_pcg32_exposer/contract.py:59
    // state, lower_bound.native, upper_bound.native, length.native
    frame_dig -3
    btoi
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    // smart_contracts/lib_pcg32_exposer/contract.py:58-60
    // state, sequence = pcg8_random(
    //     state, lower_bound.native, upper_bound.native, length.native
    // )
    callsub pcg8_random
    bury 1
    // smart_contracts/lib_pcg32_exposer/contract.py:62
    // return sequence
    retsub


// lib_pcg.xsh_rr_64_32.pcg8_init(seed: bytes) -> uint64:
pcg8_init:
    // lib_pcg/xsh_rr_64_32.py:36-37
    // @subroutine
    // def pcg8_init(seed: Bytes) -> PCG32STATE:
    proto 1 1
    // lib_pcg/xsh_rr_64_32.py:43
    // return pcg32_init(seed)
    frame_dig -1
    callsub pcg32_init
    retsub


// lib_pcg.xsh_rr_64_32.pcg8_random(state: uint64, lower_bound: uint64, upper_bound: uint64, length: uint64) -> uint64, bytes:
pcg8_random:
    // lib_pcg/xsh_rr_64_32.py:154-160
    // @subroutine
    // def pcg8_random(
    //     state: PCG32STATE,
    //     lower_bound: UInt64,
    //     upper_bound: UInt64,
    //     length: UInt64,
    // ) -> tuple[PCG32STATE, arc4.DynamicArray[arc4.UInt8]]:
    proto 4 2
    byte ""
    dupn 3
    // lib_pcg/xsh_rr_64_32.py:177
    // result = arc4.DynamicArray[arc4.UInt8]()
    byte 0x0000
    // lib_pcg/xsh_rr_64_32.py:179
    // if lower_bound == 0 and upper_bound == 0:
    frame_dig -3
    bnz pcg8_random_else_body@7
    frame_dig -2
    bnz pcg8_random_else_body@7
    // lib_pcg/xsh_rr_64_32.py:180
    // for i in urange(length):  # noqa: B007
    int 0
    frame_bury 2

pcg8_random_for_header@3:
    // lib_pcg/xsh_rr_64_32.py:180
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    frame_dig -1
    <
    bz pcg8_random_after_if_else@20
    // lib_pcg/xsh_rr_64_32.py:181
    // state, n = __pcg32_random(state)
    frame_dig -4
    callsub __pcg32_random
    swap
    frame_bury -4
    // lib_pcg/xsh_rr_64_32.py:183
    // result.append(arc4.UInt8(n))
    frame_dig 4
    extract 2 0
    swap
    itob
    extract 7 1
    concat
    dup
    len
    itob
    extract 6 2
    swap
    concat
    frame_bury 4
    // lib_pcg/xsh_rr_64_32.py:180
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    int 1
    +
    frame_bury 2
    b pcg8_random_for_header@3

pcg8_random_else_body@7:
    // lib_pcg/xsh_rr_64_32.py:185
    // if upper_bound != 0:
    frame_dig -2
    bz pcg8_random_else_body@9
    // lib_pcg/xsh_rr_64_32.py:186
    // assert upper_bound > 1
    frame_dig -2
    int 1
    >
    assert
    // lib_pcg/xsh_rr_64_32.py:187
    // assert upper_bound < (1 << 8)
    frame_dig -2
    int 256
    <
    assert
    // lib_pcg/xsh_rr_64_32.py:188
    // assert lower_bound < (upper_bound - 1)
    frame_dig -2
    int 1
    -
    frame_dig -3
    >
    assert
    // lib_pcg/xsh_rr_64_32.py:190
    // absolute_bound = upper_bound - lower_bound
    frame_dig -2
    frame_dig -3
    -
    frame_bury 0
    b pcg8_random_after_if_else@10

pcg8_random_else_body@9:
    // lib_pcg/xsh_rr_64_32.py:192
    // assert lower_bound < ((1 << 8) - 1)
    frame_dig -3
    int 255
    <
    assert
    // lib_pcg/xsh_rr_64_32.py:194
    // absolute_bound = (1 << 8) - lower_bound
    int 256
    frame_dig -3
    -
    frame_bury 0

pcg8_random_after_if_else@10:
    // lib_pcg/xsh_rr_64_32.py:196
    // threshold = __mask_to_uint32(__uint64_twos(absolute_bound)) % absolute_bound
    frame_dig 0
    dup
    callsub __uint64_twos
    callsub __mask_to_uint32
    swap
    %
    frame_bury 3
    // lib_pcg/xsh_rr_64_32.py:198
    // for i in urange(length):  # noqa: B007
    int 0
    frame_bury 2

pcg8_random_for_header@11:
    // lib_pcg/xsh_rr_64_32.py:198
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    frame_dig -1
    <
    bz pcg8_random_after_for@19

pcg8_random_while_top@13:
    // lib_pcg/xsh_rr_64_32.py:200
    // state, candidate = __pcg32_random(state)
    frame_dig -4
    callsub __pcg32_random
    dup
    cover 2
    frame_bury 1
    frame_bury -4
    // lib_pcg/xsh_rr_64_32.py:201
    // if candidate >= threshold:
    frame_dig 3
    >=
    bz pcg8_random_while_top@13
    // lib_pcg/xsh_rr_64_32.py:203
    // result.append(arc4.UInt8((candidate % absolute_bound) + lower_bound))
    frame_dig 4
    extract 2 0
    frame_dig 1
    frame_dig 0
    %
    frame_dig -3
    +
    itob
    extract 7 1
    concat
    dup
    len
    itob
    extract 6 2
    swap
    concat
    frame_bury 4
    // lib_pcg/xsh_rr_64_32.py:198
    // for i in urange(length):  # noqa: B007
    frame_dig 2
    int 1
    +
    frame_bury 2
    b pcg8_random_for_header@11

pcg8_random_after_for@19:

pcg8_random_after_if_else@20:
    // lib_pcg/xsh_rr_64_32.py:205
    // return state, result.copy()
    frame_dig -4
    frame_dig 4
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts.lib_pcg32_exposer.contract.LibPcg32ExposerAlgopy.update() -> void:
update:
    // smart_contracts/lib_pcg32_exposer/contract.py:64-65
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    // def update(self) -> None:
    proto 0 0
    // smart_contracts/lib_pcg32_exposer/contract.py:66
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    retsub
