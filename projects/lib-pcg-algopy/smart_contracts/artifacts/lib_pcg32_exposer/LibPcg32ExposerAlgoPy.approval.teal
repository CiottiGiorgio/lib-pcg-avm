#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 4294967295 4 6364136223846793005 1442695040888963407 4294967296
    txn NumAppArgs
    bz main_bare_routing@5
    pushbytes 0xa621992e // method "bounded_rand_uint32(byte[8],uint32,uint32,uint16)uint64[]"
    txna ApplicationArgs 0
    match main_bounded_rand_uint32_route@3
    err

main_bounded_rand_uint32_route@3:
    txn OnCompletion
    !
    txn ApplicationID
    &&
    assert // OnCompletion must be NoOp && can only call when not creating
    b bounded_rand_uint32

main_bare_routing@5:
    intc_1 // NoOp
    intc_3 // UpdateApplication
    txn OnCompletion
    match main___algopy_default_create@6 main_update@7
    err

main_update@7:
    txn ApplicationID
    assert // can only call when not creating
    txn Sender
    global CreatorAddress
    ==
    return

main___algopy_default_create@6:
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// lib_pcg.pcg32.__pcg32_unbounded_random(state: uint64) -> uint64, uint64:
__pcg32_unbounded_random:
    proto 1 2
    frame_dig -1
    intc 4 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    frame_dig -1
    pushint 18 // 18
    shr
    frame_dig -1
    ^
    pushint 27 // 27
    shr
    intc_2 // 4294967295
    &
    frame_dig -1
    pushint 59 // 59
    shr
    dup2
    shr
    swap
    ~
    intc_0 // 1
    addw
    bury 1
    pushint 31 // 31
    &
    uncover 2
    swap
    shl
    intc_2 // 4294967295
    &
    |
    retsub


// smart_contracts.lib_pcg32_exposer.contract.LibPcg32ExposerAlgoPy.bounded_rand_uint32[routing]() -> void:
bounded_rand_uint32:
    pushbytes ""
    dupn 4
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 8>
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 4
    ==
    assert // invalid number of bytes for arc4.uint32
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 4
    ==
    assert // invalid number of bytes for arc4.uint32
    txna ApplicationArgs 4
    dup
    len
    pushint 2 // 2
    ==
    assert // invalid number of bytes for arc4.uint16
    uncover 3
    btoi
    intc_1 // 0
    intc 4 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    bury 1
    addw
    bury 1
    intc 4 // 6364136223846793005
    mulw
    bury 1
    intc 5 // 1442695040888963407
    addw
    cover 4
    pop
    uncover 2
    btoi
    dup
    cover 3
    uncover 2
    btoi
    cover 2
    swap
    btoi
    swap
    pushbytes 0x0000
    swap
    bnz bounded_rand_uint32_else_body@9
    dig 2
    bnz bounded_rand_uint32_else_body@9
    intc_1 // 0
    dig 5
    bury 8
    bury 8

bounded_rand_uint32_for_header@6:
    dig 7
    dig 2
    <
    bz bounded_rand_uint32_after_if_else@19
    dig 6
    callsub __pcg32_unbounded_random
    swap
    bury 8
    itob
    dig 1
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 1
    dig 7
    intc_0 // 1
    +
    bury 8
    b bounded_rand_uint32_for_header@6

bounded_rand_uint32_after_if_else@19:
    pushbytes 0x151f7c75
    dig 1
    concat
    log
    intc_0 // 1
    return

bounded_rand_uint32_else_body@9:
    dig 2
    bz bounded_rand_uint32_else_body@11
    dig 2
    dup
    intc_0 // 1
    >
    assert
    dup
    intc 6 // 4294967296
    <
    assert
    dup
    intc_0 // 1
    -
    dig 5
    dup
    uncover 2
    <
    assert
    -
    bury 10

bounded_rand_uint32_after_if_else@12:
    dig 9
    dup
    ~
    intc_0 // 1
    addw
    bury 1
    intc_2 // 4294967295
    &
    swap
    %
    bury 6
    intc_1 // 0
    dig 5
    bury 8
    bury 8

bounded_rand_uint32_for_header@13:
    dig 7
    dig 2
    <
    bz bounded_rand_uint32_after_if_else@19

bounded_rand_uint32_while_top@15:
    dig 6
    callsub __pcg32_unbounded_random
    dup
    cover 2
    bury 11
    bury 8
    dig 6
    >=
    bz bounded_rand_uint32_while_top@15
    dig 8
    dig 10
    %
    dig 4
    +
    itob
    dig 1
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 1
    dig 7
    intc_0 // 1
    +
    bury 8
    b bounded_rand_uint32_for_header@13

bounded_rand_uint32_else_body@11:
    dig 3
    dup
    intc_2 // 4294967295
    <
    assert
    intc 6 // 4294967296
    swap
    -
    bury 10
    b bounded_rand_uint32_after_if_else@12
